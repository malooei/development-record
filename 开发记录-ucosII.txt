13:34 2014/9/26
开操作系统学习文档
理论基于北航 <嵌入式实时操作系统uC/OS-II>第二版
========================================================================================================================================================================================
实时操作系统基础概念篇：
========================================================================================================================================================================================

================================================================================
互斥条件：
实现任务间通信最简单的办法是使用共享数据结构。
虽然共享数据区法简化了任务间的信息交换，但是必须保证每个任务在处理共享数据时的排他性，以避免竞争和数据的破坏。

一般使共享资源满足互斥资源的一般方法：
1：关中断	2：使用测试并置位指令	3：禁止做任务切换	4：利用信号量

1 ->处理共享数据时保证互斥最简便快捷方法为关中断和开中断。
  ->必须十分小心，关中断的时间不能太长。
  ->凡好的实时内核，厂商都会提供这方面的数据。
2 ->如果不使用实时内核，那么当2个任务共享一个资源时，须约定好，先测试一全局变量，通过1或0来判断此共享资源是否被占用。
3 ->如果任务不与中断服务子程序共享变量或数据结构，可以使用“禁止”，然后允许任务切换操作（“给调度器上锁和开锁”）
  *虽然这种方式是可行的，但应该尽量避免“禁止任务切换”等操作，因为内核最主要的功能就是做任务的调度与协调
4 ->信号量实际上是一种约定机制，在多任务内核中普遍使用，信号量用于：
	1 ->控制共享资源的使用权（满足互斥条件）
	2 ->标志某事件的发生 
	3 ->使2个任务的行为同步
	
	如果信号量已被别的任务占用，那么该任务只得被挂起，直到信号量被当前使用者释放。
	换句话说，申请信号量的任务是在说：“把钥匙给我，如果谁正在用着，我只好等！”
	
	一般对信号量只能实施3种操作：初始化（建立），等信号（挂起），给信号（发信号）。
	
	收到信号量的任务可能是一下两者之一：
	1 ->等待信号量任务中优先级最高的。
	2 ->最早开始等待信号量的任务，即按先进先出FIFO的原则。

	要注意的是，在使用信号量之前，一定要对该信号量做初始化。作为互斥条件，信号量初始化为1.
	
	当诸任务共享输入/输出设备时，信号量特别有用。在这种情况下，应使用信号量，并给信号量赋初值1，规则很简单，要想使用打印机的任务，要先得到该资源的信号量。 
	
	信号量常被用过了头，处理简单的共享变量也使用信号量，则是多余的。请求和释放信号量的过程是要花费相当的时间，有时这种额外的负荷是不必要的，可能只须关中断，
	开中断处理简单的共享变量，以提高效率。
	
================================================================================
任务间通信：
有时很需要任务间或中断服务与任务间的通信。这种信息传递称为任务间的通信。
任务间信息的传递有2个途径: 1:通过全程变量   2：发消息给另一个变量

*请注意，任务只能通过全程变量与中断服务子程序通信，而任务并不知道什么时候全程变量被中断服务子程序修改，除非中断服务子程序以信号量方式向任务法信号，或者是该任务一查询的方式不断周期性的
查询变量的值。要避免这种情况的发生，可以考虑使用邮箱或消息队列。


================================================================================
消息邮箱：
通过内核服务可以给任务发送消息。典型的消息邮箱也称做交换消息，即用一个指针型变量，一个任务或一个中断服务子程序通过内核服务，可以把一则消息放到邮箱里去。

每个邮箱有相应的正在等待消息的任务列表。要得到消息的任务会因为邮箱是空的，而被挂起，且被记录到等待消息的任务表中，直到接收到消息。

消息放入邮箱后，或者把消息传给等待消息的任务列表中优先级最高的任务（基于优先级），或者将消息传给最先开始等待消息的任务（基于先进先出），而UCOSII也允许使用后进先出方式（LIFO）。

像使用邮箱那样，当一个以上的任务要从消息队列接收消息时，每个消息队列有一张等待消息任务的等待列表。如果消息队列中没有消息，即消息队列为空，则等待消息的任务就被挂起，并放入等待消
息任务列表中，知道有消息到来。

通常，内核允许等待消息的任务定义等待超时，如果限定时间内任务没有收到消息，该任务就进入就绪态并开始运行，同时返回出错代码，指出出现等待超时错误。

典型的，内核提供的消息队列服务如下：
1 ->消息队列初始化，队列初始化时总是清为空。
2 ->放一则消息到队列中去（POST）。
3 ->等待一则消息的到来（PEND）。
4 ->如果队列中有消息，则任务可以得到消息，但如果此时队列为空，内核并不将该任务挂起，如果有消息，则消息从队列中取走。

================================================================================
中断：
一种硬件机制。

中断服务子程序做事件处理，处理完成后，程序回到：
1 ->在前/后台系统中，程序回到被中断了的任务。
2 ->对不可剥夺型内核而言，程序回到被中断了的任务。
3 ->对可剥夺型内核而言，让进入就绪态的优先级最高的任务开始运行。
3 ->对可剥夺型内核而言，让进入就绪态的优先级最高的任务开始运行。

================================================================================
中断延迟：
实时内核最重要的指标可能就是关中断的时间的长短。

中断延迟 = 关中断的最长时间 + 开始执行中断服务子程序第1条指令的时间

================================================================================
中断响应：
从中断发生到开始执行用户的中断服务子程序代码来处理这个中断的时间。

对前/后台系统，保存寄存器以后立即执行用户代码
中断响应时间 = 中断延迟 + 保存CPU内部寄存器的时间

对不可剥夺型内核而言
中断响应时间 = 中断延迟 + 保存CPU内部寄存器的时间

对可剥夺型内核，则要先调用一个特定的函数
中断响应 = 中断延迟 + 保存CPU内部寄存器的时间 + 内核进入中断服务函数的执行时间































































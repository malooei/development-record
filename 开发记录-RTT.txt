13:34 2014/9/26
开源操作系统RTT学习文档
主要阅读文献《RT-Thread实时操作系统编程指南》（版本0.3.0），RT-Thread编程指南（2014-05-19）


阅读记录：
18:24 2014/10/2 记录到第四章任务间同步及通信，跳过第三章定时器

	
========================================================================================================================================================================================

第二章	线程调度与管理
======================================================================================================
2.1	实时系统的需求
======================================================================================================
所以实时系统也可以看成是一个等级系统，不同重要性的任务具有不同的优先等级：重要的事件能够优先被响应执行，非重要的事件可以适当往后推迟。

线程是RT-Thread中最基本的调度单位。

并且可以类似Linux一样具备分时的效果。


2.2	线程调度器、
======================================================================================================
RT-Thread中提供的线程调度器是基于优先级的全抢占式调度：



在系统中除中断处理函数，调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统其它部分都是可以抢占的包括线程调度器本身。

系统支持256个优先级（0~255，数值越小的优先级越高，0为最高优先级，255分配给空闲线程使用，一般用户不）

在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将立刻被换出，高优先级线程抢占处理器运行。

RT-Thread内核中采用了基于位图的优先级算法（时间复杂度O(1)，即与就绪线程的多少无关），通过位图的定位快速的获得优先级最高的线程。

RT-Thread内核中也允许创建相同优先级的线程。相同优先级的线程采用时间片轮转方式进行调度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪线程存在的情况下才有效。

为了保证系统的实时性，系统尽最大可能地保证高优先级的线程得以运行。线程调度的原则是一旦任务状态发生了改变，并且当前运行的线程优先级小于优先级队列组中线程最高优先级时，立刻进行线程切换
（除非当前系统处于中断处理程序中或禁止线程切换的状态）。

每个线程的时间片大小都可以在初始化或创建这个线程时指定。


2.3	线程控制块
======================================================================================================
线程控制块是操作系统用于控制线程的一个数据结构，它会存放线程的一些信息，例如优先级，线程名称等，也包含线程与线程之间连接用的链表结构，线程等待事件集合等。

在RT-Thread实时操作系统中，线程控制块由结构体struct rt_thread表示。

/* rt_thread_t线程句柄，指向线程控制块的指针*/
typedef struct rt_thread* rt_thread_t;
/*
* 线程控制块
*/
struct rt_thread
{
        /* RT-Thread根对象定义*/
        char name[RT_NAME_MAX];    			/* 对象的名称*/
        rt_uint8_t type; 					/* 对象的类型*/
        rt_uint8_t flags; 					/* 对象的参数*/
        
#ifdef RT_USING_MODULE
        void *module_id; 					/* 线程所在的模块ID*/
#endif
        
		rt_list_t list; 					/* 对象链表*/
        rt_list_t tlist; 					/* 线程链表*/
        
		/* 栈指针及入口*/
        void* sp; 							/* 线程的栈指针*/
        void* entry; 						/* 线程入口*/
        void* parameter; 					/* 线程入口参数*/
        void* stack_addr; 					/* 线程栈地址*/
        rt_uint16_t stack_size; 			/* 线程栈大小*/
        rt_err_t error; 					/* 线程错误号*/
        rt_uint8_t stat; 					/* 线程状态*/
 
		/* 优先级相关域*/
        rt_uint8_t current_priority;		/* 当前优先级*/
        rt_uint8_t init_priority; 			/* 初始线程优先级*/
		
#if RT_THREAD_PRIORITY_MAX > 32
        rt_uint8_t number;
        rt_uint8_t high_mask;
#endif

        rt_uint32_t number_mask;

#if defined(RT_USING_EVENT)
        /* 事件相关域*/
        rt_uint32_t event_set;
        rt_uint8_t event_info;
#endif

        rt_ubase_t init_tick; 				/* 线程初始tick*/
        rt_ubase_t remaining_tick;			/* 线程当次运行剩余tick */
        struct rt_timer thread_timer; 		/* 线程定时器*/

        /* 当线程退出时，需要执行的清理函数*/
        void (*cleanup)(struct rt_thread *tid);
        rt_uint32_t user_data;				/* 用户数据*/
};



2.4	线程状态
======================================================================================================
线程运行的过程中，一个时间内只允许一个线程在处理器中运行，从运行的过程上划分，线程有多种不同的运行状态。

在RT-Thread实时操作系统中，线程包含五种状态，操作系统会自动根据它运行的情况而动态调整它的状态。

RT-Thread中的五种线程状态如下所示：

状态					描述

RT_THREAD_INIT 			线程初始状态。当线程刚开始创建还没开始运行时就处于这个状态；在这个状态下，线程不参与调度

RT_THREAD_SUSPEND 		挂起态、阻塞态。线程此时被挂起：它可能因为资源不可用而挂起等待；或线程主动延时一段时间而被挂起。在这个状态下，线程不参与调度

RT_THREAD_READY 		就绪态。线程正在运行；或当前线程运行完让出处理器后，操作系统寻找最高优先级的就绪态线程运行

RT_THREAD_RUNNING 		运行态。线程当前正在运行，在单核系统中，只有rt_thread_self()函数返回的线程处于这个状态；在多核系统中则不受这个限制。

RT_THREAD_CLOSE 		线程结束态。当线程运行结束时将处于这个状态。这个状态的线程不参与线程的调度。



RT-Thread实时操作系统提供一系列的操作系统调用接口，使得线程的状态在这五个状态之间来回的变换。
*****参见图2.2: 线程转换图*****




2.5	空闲线程
======================================================================================================
空闲线程是系统线程中一个比较特殊的线程，它具有最低的优先级，当系统中无其他线程可运行时，调度器将调度到空闲线程。空闲线程通常是一个死循环，永远不被挂起。

RT-Thread实时操作系统为空闲线程提供了钩子函数，可以让系统在空闲的时候执行一些特定的任务，例如系统运行指示灯闪烁，电源管理等。





2.6	调度器有关接口
======================================================================================================
2.6.1	调度器初始化
======================================================================================================
在系统启动时需要执行调度器的初始化，以初始化系统调度器用到的一些全局变量。
调度器初始化可以调用下面的函数接口：
void rt_system_scheduler_init(void)



2.6.2	启动调度器
======================================================================================================
在系统完成初始化后切换到第一个线程，可以调用下面的函数接口:
void rt_system_scheduler_start(void)



2.6.3	执行调度
======================================================================================================
让调度器执行一次线程的调度可通过下面的函数接口:
void rt_schedule(void)



2.6.4	设置调度器钩子
======================================================================================================
有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。
在系统线程切换时，这个钩子函数将被调用：
void rt_scheduler_sethook(void (*hook)(struct rt_thread* from, struct rt_thread* to))



2.7	线程相关接口
======================================================================================================

2.7.1	线程创建
======================================================================================================
一个线程要成为可执行的对象就必须由操作系统的内核来为它创建（初始化）一个线程句柄。
可以通过如下的函数接口来创建一个线程:

rt_thread_t rt_thread_create(const char* name,
void (*entry)(void* parameter), void* parameter,
rt_uint32_t stack_size,
rt_uint8_t priority, rt_uint32_t tick);



2.7.2	线程删除
======================================================================================================
对于一些使用rt_thread_create创建出来的线程，当不需要使用，或者运行出错时，我们可以使用下面的函数接口来从系统中把线程完全删除掉：

rt_err_t rt_thread_delete(rt_thread_t thread);

线程删除后：
1：线程对象将会被移出线程队列
2：从内核对象管理器中删除
3：线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。


2.7.3	线程初始化
======================================================================================================
线程的初始化可以使用下面的函数接口完成：

rt_err_t rt_thread_init(struct rt_thread* thread,
const char* name,
void (*entry)(void* parameter), void* parameter,
void* stack_start, rt_uint32_t stack_size,
rt_uint8_t priority, rt_uint32_t tick);
  
 

2.7.4	线程脱离
======================================================================================================
线程脱离将使线程对象在线程队列和内核对象管理器中被删除。线程脱离使用下面的函数：
rt_err_t rt_thread_detach (rt_thread_t thread);

rt_thread_delete()函数操作的对象是rt_thread_create()创建的句柄，而rt_thread_detach()函数操作的对象是使用rt_thread_init()函数初始化的线程控制块。

2.7.5	线程启动
======================================================================================================
创建（初始化）的线程对象的状态处于初始态，并未进入就绪线程的调度队列，我们可以调用下面的函数接口启动一个线程：

rt_err_t rt_thread_startup(rt_thread_t thread);

当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。如果新启动的线程优先级比当前线程优先级高，将立刻切换到这个线程。



2.7.6	当前线程
======================================================================================================
在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄。
rt_thread_t rt_thread_self(void);


2.7.7	线程让出处理器
======================================================================================================
当前线程的时间片用完或者该线程自动要求让出处理器资源时，它不再占有处理器，调度器会选择下一个最高优先级的线程执行。
这时，放弃处理器资源的线程仍然在就绪队列中。线程让出处理器使用下面的函数接口：

rt_err_t rt_thread_yield(void);

调用该函数后，当前线程首先把自己从它所在的队列中删除，然后把自己挂到与该线程优先级对应的就绪线程链表的尾部，然后激活调度器切换到优先级最高的线程。

注：rt_thread_yield()函数和rt_schedule()函数比较相像，但在有相同优先级的其他就绪态线程存在时，系统的行为却完全不一样。执行rt_thread_yield()函数后，将
	当前线程被换出，把相同优先级的下一个就绪线程将被执行。而执行rt_schedule()函数后，当前线程并不一定被换出，即使被换出，也不会被放到绪线程链表的尾部，而
	是在系统中选取就绪的优先级最高的线程执行（如果系统中没有比当前线程优先级更高的线程存在，那么执行完rt_schedule()函数后，系统将继续执行当前线程）。


2.7.8	线程睡眠
======================================================================================================
在实际应用中，我们有时需要让运行的当前线程延迟一段时间，在指定的时间到达后重新运行，这就叫做“线程睡眠”。线程睡
眠可使用以下两个函数接口：
rt_err_t rt_thread_sleep(rt_tick_t tick);
rt_err_t rt_thread_delay(rt_tick_t tick);

这两个函数接口的作用相同，调用它们可以使当前线程挂起一段指定的时间，当这个时间过后，线程会被唤醒并再次进入就绪状态。这个函数接受一个参数，该参数指定了线程的
休眠时间（单位是OS Tick时钟节拍）。


2.7.9	线程挂起
======================================================================================================
当线程调用rt_thread_delay，调用线程将主动挂起，当调用rt_sem_take，rt_mb_recv等函数时，资源不可使用也将导致调用线
程挂起。处于挂起状态的线程，如果其等待的资源超时（超过其设定的等待时间），那么该线程将不再等待这些资源，并返回到就
绪状态；或者，当其它线程释放掉该线程所等待的资源时，该线程也会返回到就绪状态。线程挂起使用下面的函数接口：

rt_err_t rt_thread_suspend (rt_thread_t thread);

注：通常不应该使用这个函数来挂起线程本身，如果确实需要采用rt_thread_suspend函数挂起当前任务，需要在调用rt_thread_suspend()函数后立刻调用rt_schedule()函
数进行手动的线程上下文切换。


2.7.10	线程恢复
======================================================================================================
线程恢复就是让挂起的线程重新进入就绪状态，如果被恢复线程在所有就绪态线程中，位于最高优先级链表的第一位，那么系统将
进行线程上下文的切换。线程恢复使用下面的函数接口：
rt_err_t rt_thread_resume (rt_thread_t thread);



2.7.11	线程控制
======================================================================================================
当需要对线程进行一些其他控制时，例如动态更改线程的优先级，可以调用如下函数接口：

rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void* arg);

指示控制命令cmd当前支持的命令包括
? RT_THREAD_CTRL_CHANGE_PRIORITY - 动态更改线程的优先级；
? RT_THREAD_CTRL_STARTUP - 开始运行一个线程，等同于rt_thread_startup()函数调用；
? RT_THREAD_CTRL_CLOSE - 关闭一个线程，等同于rt_thread_delete()函数调用。



2.7.12	初始化空闲线程
======================================================================================================
根据前面的描述，系统运行过程中必须存在一个最终可运行的线程，可以调用如下函数初始化空闲线程：
void rt_thread_idle_init(void);




2.7.13	设置空闲线程钩子
======================================================================================================
可以调用如下的函数，设置空闲线程运行时执行的钩子函数。

void rt_thread_idle_set_hook(void (*hook)(void));

当空闲线程运行时会自动执行设置的钩子函数，由于空闲线程具有系统的最低优先级，所以只有在空闲的时候才会执行此钩子函数。空闲线程是一个线程状态永远为就绪
态的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，例如rt_thread_delay() ， rt_sem_take() 等可能会导致线程挂起的函数都不能使用。


2.8 线程设计
======================================================================================================
2.8.1	程序的运行上下文
======================================================================================================
RT-Threadz中程序运行的上下文包括：
* 中断服务例程；
* 普通线程；
* 空闲线程；


空闲线程 		-> 空闲线程是RT-Thread系统中采用idle线程钩子方式，在idle线程上钩入自己的功能函数。通常这个空闲线程
				   钩子能够完成一些额外的特殊功能，例如系统运行状态的指示，系统省电模式等。

中断服务例程		-> 中断服务例程是一种需要特别注意的上下文环境，它运行在非线程的执行环境下（一般为芯片的一种特殊运行
			       模式），在这个上下文环境中不能进行挂起当前线程的操作，因为当前线程并不存在；
				   
		需要注意的是，中断服务程序最好保持精简短小，因为中断服务是一种高于任何线程的存在。

普通线程；		-> 普通线程看似没有什么限制程序执行的因素，似乎所有的操作都可以执行。

		需要注意的是，做为一个实时系统，一个优先级明确的实时系统，如果一个线程中的程序执行了死循环操作，那么比它优
					先级低的线程都将不能够得到执行，当然也包括了idle线程。这个是在RT-Thread系统中必须注意的一点。				   

		

2.8.2	线程设计要点
======================================================================================================
在实时系统的章节中提到过，实时系统多数是一种被动的系统，被动的响应外部事件，当外部事件触发后执行设定的工作内容。所以
在对系统进行线程设计时，需要考虑到：

1:上下文环境：

对于工作内容，首先需要思考它的执行环境是什么。工作内容与工作内容间是否有重叠的部分，是否能够合并到一起进行处理，或者
单独划分开进行处理。


2：线程的状态跃迁：

这里说的状态跃迁指的是线程运行中状态的变化，从就绪态过渡到挂起态。实时系统一般被设计成一种优先级的系统，如果一个线程
只有就绪态而无阻塞态，势必会影响到其他低优先级线程的执行。所以在进行线程设计时，就应该保证线程在不活跃的时候，必须让
出处理器，即线程能够主动让出处理器资源，进入到阻塞状态。这需要设计者在设计线程的时候就明确的知道什么情况下需要让线程
从就绪态跃迁到阻塞态。

3：线程运行时间长度：
线程运行时间长度被定义为，在线程所关心的一种事件或多种事件触发状态下，线程由阻塞态跃迁为就绪态执行设定的工作，再从就
绪态跃迁为阻塞态所需要的时间（一般还应加上这段时间内，这个线程不会被其它线程所抢占的先决条件）。线程运行时间长度将和
线程的优先级设计密切相关，同时也决定着设计的系统是否能够满足预计的实时响应的指标。

注意：对实时系统与优先级之间关系的理解：对于事件A对应的服务线程Ta，系统要求的实时响应指标是1ms，而Ta的最大运
	  行时间是500us。此时，系统中还存在着以50ms为周期的另一线程Tb，它每次运行的最大时间长度是100us。在这种情况下，即
	  使把线程Tb的优先级抬到比Ta更高的位置，对系统的实时性指标也没什么影响（因为即使在Ta的运行过程中，Tb抢占了Ta的资
	  源，但在规定的时间内(1ms)，Ta也能够完成对事件A的响应）。






========================================================================================================================================================================================

第三章	定时器
========================================================================================================================================================================================
3.1	定时器管理
======================================================================================================

定时器，是指从指定的时刻开始，经过一个指定时间，然后触发一个事件。

定时器有硬件定时器和软件定时器之分：

硬件定时器 -> 是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯
			  片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。

软件定时器 -> 由操作系统提供的一类系统接口（函数），它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。

在操作系统中，通常软件定时器以系统节拍（tick）为单位,节拍长度指的是周期性硬件定时器两次中断间的间隔时间长度。这个周期性硬件定时器也称之为操作系统时钟。

由于节拍定义了系统中定时器能够分辨的精确度，系统可以根据实际系统CPU的处理能力和实时性需求设置合适的数值，tick值设置越小，精度越高，但是系统开销也将越大
（在1秒中系统用于处理时钟中断的次数也就越多）。

RT-Thread的定时器也基于类似的系统节拍，提供了基于节拍整数倍的定时能力。


RT-Thread的定时器提供两类定时器机制：
1 -> 单次触发定时器 -> 这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。

2 -> 周期触发定时器 -> 这类定时器会周期性的触发定时器事件，直到用户手动的停止定时器否则将永远持续执行下去。


在RT-Thread定时器模块中维护着两个重要的全局变量：
1 -> 当前系统经过的tick时间rt_tick（当硬件定时器中断来临时，它将加1）；

2 -> 定时器链表rt_timer_list。系统新创建并激活的定时器都会按照以超时时间排序的方式插入到rt_timer_list链表中。




3.2	定时器超时函数
======================================================================================================
软定时器最主要的目的是在系统经过设定的时间后，系统能够自动执行用户设定的动作。当定时器设定的时间到了，即超时时，执行的动作函数称之为定时器的超时函数。

在RT-Thread实时操作系统中，定时器超时函数存在着两种情况：
1 -> 超时函数在（系统时钟）中断上下文环境中执行；
2 -> 超时函数在线程的上下文环境中执行。

如果超时函数是在中断上下文环境中执行，显然对于超时函数的要求与中断服务例程的要求相同：执行时间应该尽量短，执行时不应导致当前上下文挂起、等待。



3.3	定时器管理控制块
======================================================================================================
struct rt_timer
{
		struct rt_object_parent;
		rt_list_t list; /* 用于链接定时器的链表*/

		void (*timeout_func)(void* parameter); /* 定时器超时调用的函数*/
		void *parameter; /* 超时函数用到的入口参数*/

		rt_tick_t init_tick; /* 定时器初始超时节拍数*/
		rt_tick_t timeout_tick; /* 定时器实际超时时的节拍数*/
};

typedef struct rt_timer* rt_timer_t;

定时器控制块由struct rt_timer结构体定义，并形成定时器内核对象再链接到内核对象容器中进行管理。list成员则用于把一个激活的（已经启动的）定时器链接到
rt_timer_list链表中。



3.4	定时器管理接口  
======================================================================================================

3.4.1	定时器管理系统初始化  
======================================================================================================
初始化定时器管理系统，可以通过下面的函数接口完成：

void rt_system_timer_init(void);


注意：如果需要使用SOFT_TIMER，则系统初始化时，应该调用下面这个函数接口：

void rt_system_timer_thread_init(void);


3.4.2	创建定时器  
======================================================================================================
当动态创建一个定时器时，可使用下面的函数接口：

rt_timer_t rt_timer_create(const char* name,void (*timeout)(void* parameter), void* parameter, rt_tick_t time, rt_uint8_t flag);

调用该函数接口后，内核首先从动态内存堆中分配一个定时器控制块，然后对该控制块进行基本的初始化。


3.4.3	删除定时器
======================================================================================================
系统不再使用特定定时器时，可使用下面的函数接口：

rt_err_t rt_timer_delete(rt_timer_t timer);

调用这个函数接口后，系统会把这个定时器从rt_timer_list链表中删除，然后释放相应的定时器控制块占有的内存。


3.4.4	初始化定时器  
======================================================================================================
当选择静态创建定时器时，可利用rt_timer_init接口来初始化该定时器，函数接口如下：

void rt_timer_init(rt_timer_t timer, const char* name, void (*timeout)(void* parameter), void* parameter, rt_tick_t time, rt_uint8_t flag);

使用该函数接口时会初始化相应的定时器控制块，初始化相应的定时器名称，定时器超时函数等等。


3.4.5	脱离定时器  
======================================================================================================
当一个静态定时器不需要再使用时，可以使用下面的函数接口：

rt_err_t rt_timer_detach(rt_timer_t timer);

脱离定时器时，系统会把定时器对象从系统容器的定时器链表中删除，但是定时器对象所占有的内存不会被释放。


3.4.6	启动定时器  
======================================================================================================
当定时器被创建或者初始化以后，并不会被立即启动，必须在调用启动定时器函数接口后，才开始工作，启动定时器函数接口如下：

rt_err_t rt_timer_start(rt_timer_t timer);

调用定时器启动函数接口后，定时器的状态将更改为激活状态（RT_TIMER_FLAG_ACTIVATED），并按照超时顺序插入到rt_timer_list队列链表中。

函数返回
如果timer已经处于激活状态，则返回-RT_ERROR；否则返回RT_EOK。

3.4.7	停止定时器
======================================================================================================
启动定时器以后，若想使它停止，可以使用下面的函数接口：

rt_err_t rt_timer_stop(rt_timer_t timer);

调用定时器停止函数接口后，定时器状态将更改为停止状态，并从rt_timer_list链表中脱离出来不参与定时器超时检查。当一个（周期性）定时器超时时，也可以
调用这个函数接口停止这个（周期性）定时器本身。

函数返回
如果timer已经处于停止状态，返回-RT_ERROR；否则返回RT_EOK。


3.4.8	控制定时器
======================================================================================================
除了上述提供的一些编程接口，RT_thread也额外提供了定时器控制函数接口，以获取或设置更多定时器的信息。控制定时器函数接口如下：

rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void* arg);

控制定时器函数接口可根据命令类型参数，来查看或改变定时器的设置。




3.5	合理使用定时器
======================================================================================================
3.5.1	定时器执行上下文
======================================================================================================
RT-Thread的定时器与其他实时操作系统的定时器实现稍微有些不同（特别是RT-Thread早期版本的实现中），因为RT-Thread里定时器默认的方式是HARD_TIMER定时器，
即定时器超时后，超时函数是在系统时钟中断的上下文环境中运行的。

1 -> 在中断上下文中的执行方式决定了定时器的超时函数不应该调用任何会让当前上下文挂起的系统函数；

2 -> 也不能够执行非常长的时间，否则会导致其他中断的响应时间加长或抢占了其他线程执行的时间。




3.5.2	OS tick与定时器精度
======================================================================================================
系统中HARD_TIMER定时器的最小精度是由系统时钟节拍所决定的（1 OS tick = 1/RT_TICK PERSECOND秒，RT_TICK_PER_SECOND值在rtconfig.h文件中定义），定时器设
定的时间必须是OS tick的整数倍。

当需要实现更短时间长度的系统定时时，例如OS tick是10ms，而程序需要实现1ms的定时或延时，这种时候操作系统定时器将不能够满足要求，只能通过读取系统某个硬件
定时器的计数器或直接使用硬件定时器的方式。

在Cortex-M3中，SysTick已经被RT-Thread用于作为OS tick使用，它被配置成1/RT_TICK_PER_SECOND秒后触发一次中断的方式，中断处理函数使用Cortex-M3默认的SysTick_Handler
名字。





========================================================================================================================================================================================

第四章	任务间同步及通信
======================================================================================================
在多任务实时系统中，一项工作的完成往往可以通过多个任务协调的方式共同来完成，例如一个任务从传感器中接收数据并且将数据
写到共享内存中，同时另一个任务周期性的从共享内存中读取数据并发送去显示（如图两个线程间的数据传递）。


如果对共享内存的访问不是排他性的，那么各个线程间可能同时访问它。这将引起数据一致性的问题。


将传感器数据写入到共享内存的代码是接收线程的关键代码段；将传感器数据从共享内存中读出的代码是显示线程的关键代码段；这
两段代码都会访问共享内存。正常的操作序列应该是在一个线程对共享内存块操作完成后，才允许另一个线程去操作。

对于操作/访问同一块区域，称之为临界区。

对于操作/访问同一块区域，称之为临界区。任务的同步方式有很多种，其核心思想都是：在访问临界区的时候只允许一个(或一类)任
务运行。



4.1	关闭中断
======================================================================================================
关闭中断也叫中断锁，是禁止多任务访问临界区最简单的一种方式，即使是在分时操作系统中也是如此。当中断关闭的时候，就意味着
当前任务不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除
非这个任务主动放弃了处理器控制权。


关闭、打开中断接口由两个函数完成：
1:关闭中断
rt_base_t rt_hw_interrupt_disable(void);
2:恢复中断
void rt_hw_interrupt_enable(rt_base_t level);

警告: 由于关闭中断会导致整个系统不能响应外部中断，所以在使用关闭中断做为互斥访问临界区的手段时，首先必须需要保证关闭中断的时间非常短，例如数条机器指
	  令。


4.1.1 使用场合
======================================================================================================
使用中断锁来操作系统的方法可以应用于任何场合，且其他几类同步方式都是依赖于中断锁而实现的，可以说中断锁是最强大的和最高
效的同步方法。

只是使用中断锁最主要的问题在于，在中断关闭期间系统将不再响应任何中断，也就不能响应外部的事件。所以中断锁对系统的实时性
影响非常巨大，当使用不当的时候会导致系统完全无实时性可言（可能导致系统完全偏离要求的时间需求）；而使用得当，则会变成一
种快速、高效的同步方式。

例如，为了保证一行代码（例如赋值）的互斥运行，最快速的方法是使用中断锁而不是信号量或互斥量：

/* 关闭中断*/
level = rt_hw_interrupt_disable();
a = a + value;
/* 恢复中断*/
rt_hw_interrupt_enable(level);

在rt_sem_take 、rt_sem_release 的实现中，已经存在使用中断锁保护信号量内部变量的行为，所以对于简单如a = a + value;的操作，使用中断锁将更为简洁快速。



4.2	调度器锁
======================================================================================================
同中断锁一样把调度器锁住也能让当前运行的任务不被换出，直到调度器解锁。但和中断锁有一点不相同的是，对调度器上锁，系统依
然能响应外部中断，中断服务例程依然能进行相应的响应。所以在使用调度器上锁的方式进行任务同步时，需要考虑好任务访问的临界
资源是否会被中断服务例程所修改，如果可能会被修改，那么将不适合采用此种方式进行同步。

RT-Thread提供的调度锁操作API为：
void rt_enter_critical(void); /* 进入临界区*/

调用这个函数后，调度器将被上锁。在系统锁住调度器的期间，系统依然响应中断，如果中断唤醒了的更高优先级线程，调度器并不会
立刻执行它，直到调用解锁调度器函数才尝试进行下一次调度。
void rt_exit_critical(void); /* 退出临界区*/

当系统退出临界区的时候，系统会计算当前是否有更高优先级的线程就绪，如果有比当前线程更高优先级的线程就绪，将切换到这个高
优先级线程中执行；如果无更高优先级线程就绪，将继续执行当前任务。

? 注意： rt_enter_critical/rt_exit_critical可以多次嵌套调用，但每调用一次rt_enter_critical
	就必须相对应地调用一次rt_exit_critical退出操作，嵌套的最大深度是65535。


4.2.1 使用场合
======================================================================================================
调度器锁能够方便地使用于一些线程与线程间同步的场合，由于轻型，它不会对系统中断响应造成负担；但它的缺陷也很明显，就是它
不能被用于中断与线程间的同步或通知，并且如果执行调度器锁的时间过长，会对系统的实时性造成影响（因为使用了调度器锁后，系
统将不再具备优先级的关系，直到它脱离了调度器锁的状态）。



4.3	信号量
======================================================================================================
信号量是一种轻型的用于解决线程间同步问题的内核对象，线程可以获取或释放它，从而达到同步或互斥的目的。信号量就像一把钥匙，
把一段临界区给锁住，只允许有钥匙的线程进行访问：线程拿到了钥匙，才允许它进入临界区；而离开后把钥匙传递给排队在后面的等
待线程，让后续线程依次进入临界区。

信号量工作示意图如图信号量工作示意图所示，每个信号量对象都有一个信号量值和一个线程等待队列，信号量的值对应了信号量对象
的实例数目、资源数目。


4.3.1 信号量控制块
======================================================================================================

struct rt_semaphore
{
		struct rt_ipc_object parent;/*继承自ipc_object类*/
		rt_uint16_t value; /* 信号量的值*/
};
/* rt_sem_t是指向semaphore结构体的指针类型*/

typedef struct rt_semaphore* rt_sem_t;


rt_semaphore对象从rt_ipc_object中派生，由IPC容器所管理。信号量的最大值是
65535。



4.3.2 信号量相关接口
======================================================================================================
当创建一个信号量时，内核首先创建一个信号量控制块，然后对该控制块进行基本的初始化工作，创建信号量使用下面的函数接口：

rt_sem_t rt_sem_create (const char* name, rt_uint32_t value, rt_uint8_t flag);

当选择FIFO方式时，那么等待线程队列将按照先进先出的方式排队，先进入的线程将先获得等待的信号量；当选择PRIO（优先级等待）方式
时，等待线程队列将按照优先级进行排队，优先级高的等待线程将先获得等待的信号量。




删除信号量
系统不再使用信号量时，可通过删除信号量以释放系统资源。删除信号量使用下面的函数接口：

rt_err_t rt_sem_delete (rt_sem_t sem);




初始化信号量
对于静态信号量对象，它的内存空间在编译时期就被编译器分配出来，放在数据段或ZI段上，此时使用信号量就不再需要使用rt_sem_create
接口来创建它，而只需在使用前对它进行初始化即可。初始化信号量对象可使用下面的函数接口：

rt_err_t rt_sem_init (rt_sem_t sem, const char* name, rt_uint32_t value, rt_uint8_t flag);




脱离信号量
脱离信号量就是让信号量对象从内核对象管理器中移除掉。脱离信号量使用下面的函数接口：

rt_err_t rt_sem_detach (rt_sem_t sem);

使用该函数后，内核先唤醒所有挂在该信号量等待队列上的线程，然后将该信号量从内核对象管理器中删除。原来挂起在信号量上的等待线程将获得-RT_ERROR 的返回值。




获取信号量
线程通过获取信号量来获得信号量资源实例，当信号量值大于零时，线程将获得信号量，并且相应的信号量值都会减1，获取信号量使用下面
的函数接口：

rt_err_t rt_sem_take (rt_sem_t sem, rt_int32_t time);

在调用这个函数时，如果信号量的值等于零，那么说明当前信号量资源实例不可用，申请该信号量的线程将根据time参数的情况选择直接返回、或挂起等待一段时间、或永久等
待，直到其他线程或中断释放该信号量。如果在参数time指定的时间内依然得不到信号量，线程将超时返回，返回值是-RT_ETIMEOUT。



	
无等待获取信号量
当用户不想在申请的信号量上挂起线程进行等待时，可以使用无等待方式获取信号量，无等待获取信号量使用下面的函数接口：

rt_err_t rt_sem_trytake(rt_sem_t sem);
	
这个函数与rt_sem_take(sem, 0) 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回-RT_ETIMEOUT。
	

	
	
释放信号量
当线程完成资源的访问后，应尽快释放它持有的信号量，使得其他线程能获得该信号量。释放信号量使用下面的函数接口：

rt_err_t rt_sem_release(rt_sem_t sem);

当信号量的值等于零时，并且有线程等待这个信号量时，将唤醒等待在该信号量线程队列中的第一个线程，由它获取信号量。否则将把信号量的
值加一。
	



注意：semaphore是作为一种锁的形式存在，当要访问临界资源：ring buffer时，通过持有semaphore 的形式阻止其他线程进入（如果其他线程也打算进入，将在这里
	 被挂起）。
	
	
	
	
4.3.3 使用场合
======================================================================================================
信号量是一种非常灵活的同步方式，可以运用在多种场合中。形成锁，同步，资源计数等关系，也能方便的用于线程与线程，中断与线程的同步
中。

线程同步 		-> 线程同步是信号量最简单的一类应用。例如，两个线程用来进行任务间的执行控制转移，信号量的值初始化成具备0个信号量
				   资源实例，而等待线程先直接在这个信号量上进行等待。当信号线程完成它处理的工作时，释放这个信号量，以把等待在这个
				   信号量上的线程唤醒，让它执行下一部分工作。这类场合也可以看成把信号量用于工作完成标志：信号线程完成它自己的工作，
				   然后通知等待线程继续下一部分工作。
	
锁		 		->锁，单一的锁常应用于多个线程间对同一临界区的访问。信号量在作为锁来使用时，通常应将信号量资源实例初始化成1，
				  代表系统默认有一个资源可用。当线程需要访问临界资源时，它需要先获得这个资源锁。当这个线程成功获得资源锁时，其
				  他打算访问临界区的线程将被挂起在该信号量上，这是因为其他线程在试图获取这个锁时，这个锁已经被锁上（信号量值是
				  0）。当获得信号量的线程处理完毕，退出临界区时，它将会释放信号量并把锁解开，而挂起在锁上的第一个等待线程将被
				  唤醒从而获得临界区的访问权。

中断与线程的同步 ->信号量也能够方便的应用于中断与线程间的同步，例如一个中断触发，中断服务例程需要通知线程进行相应的数据处理。这
				  个时候可以设置信号量的初始值是0，线程在试图持有这个信号量时，由于信号量的初始值是0，线程直接在这个信号量上挂
				  起直到信号量被释放。当中断触发时，先进行与硬件相关的动作，例如从硬件的I/O口中读取相应的数据，并确认中断以清除
				  中断源，而后释放一个信号量来唤醒相应的线程以做后续的数据处理。

				  semaphore先初始为0，而后shell线程试图取得信号量，因为信号量值是0，所以它会被挂起。当console设备有数据输入时，将
				  产生中断而进入中断服务例程。在中断服务例程中，它会读取console设备的数据，并把读得的数据放入uart buffer中进行缓冲
				  ，而后释放信号量，释放信号量的操作将唤醒shell线程。在中断服务例程运行完毕后，如果系统中没有比shell线程优先级更高
				  的就绪线程存在时，shell线程将持有信号量并运行，从uart buffer缓冲区中获取输入的数据。
				  
				 ? 警告： 中断与线程间的互斥不能采用信号量（锁）的方式，而应采用中断锁。



				  
				  
4.4	互斥量
======================================================================================================
互斥量又叫相互排斥的信号量，是一种特殊的二值性信号量。它和信号量不同的是，它支持互斥量所有权、递归访问以及防止优先级翻转的特性。

互斥量的状态只有两种，开锁或闭锁（两种状态值）。当有线程持有它时，互斥量处于闭锁状态，由这个线程获得它的所有权。相反，当这个线程
释放它时，将对互斥量进行开锁，失去它的所有权。

优先级翻转的原因	->使用信号量会导致的另一个潜在问题是线程优先级翻转。所谓优先级翻转问题即当一个高优先级线程试图通过信号量机制
					  访问共享资源时，如果该信号量已被一低优先级线程持有，而这个低优先级线程在运行过程中可能又被其它一些中等优先
					  级的线程抢占，因此造成高优先级线程被许多具有较低优先级的线程阻塞，实时性难以得到保证。例如：有优先级为
					  A、B和C的三个线程，优先级A> B > C。线程A，B处于挂起状态，等待某一事件触发，线程
					  C正在运行，此时线程C开始使用某一共享资源M。在使用过程中，线程A等待的事件到来，
					  线程A转为就绪态，因为它比线程C优先级高，所以立即执行。但是当线程A要使用共享资源
					  M时，由于其正在被线程C使用，因此线程A被挂起切换到线程C运行。如果此时线程B等待
					  的事件到来，则线程B转为就绪态。由于线程B的优先级比线程C高，因此线程B开始运行，
					  直到其运行完毕，线程C才开始运行。只有当线程C释放共享资源M后，线程A才得以执行。
					  在这种情况下，优先级发生了翻转，线程B先于线程A运行。这样便不能保证高优先级线程
					  的响应时间。

优先级继承解决优先级翻转过程	->
					 在RT-Thread操作系统中实现的是优先级继承算法。优先级继承是通过在线程A被阻塞
					 的期间内，将线程C的优先级提升到线程A的优先级别，从而解决优先级翻转引起的问题。
					 这样能够防止C（间接地防止A）被B抢占。优先级继承协议是指，提高某个占有某种资源的
					 低优先级线程的优先级，使之与所有等待该资源的线程中优先级最高的那个线程的优先级相
					 等，然后执行，而当这个低优先级线程释放该资源时，优先级重新回到初始设定。因此，继
					 承优先级的线程避免了系统资源被任何中间优先级的线程抢占。

					? 警告： 在获得互斥量后，请尽快释放互斥量，并且在持有互斥量的过程中，不得再行
					更改持有互斥量线程的优先级。
					  

4.4.1 互斥量信号块
======================================================================================================
互斥量控制块的数据结构

struct rt_mutex
{
		struct rt_ipc_object parent; /* 继承自ipc_object类*/
		rt_uint16_t value; /* 互斥量的值*/
		rt_uint8_t original_priority; /* 持有线程的原始优先级*/
		rt_uint8_t hold; /* 持有线程的持有次数*/
		struct rt_thread *owner; /* 当前拥有互斥量的线程*/
};

/* rt_mutext_t为指向互斥量结构体的指针*/
typedef struct rt_mutex* rt_mutex_t;

rt_mutex对象从rt_ipc_object中派生，由IPC容器管理

IPC机制（Inter-Process Communication）----意思是进程间通信。RT-Thread中IPC对象有：信号量、互斥锁、事件、消息队列、邮箱。

4.4.2 互斥量相关接口
======================================================================================================
创建互斥量   ->创建一个互斥量时，内核首先创建一个互斥量控制块，然后完成对该控制块的初始化工作。创建互斥量使用下面的函数接口：
			   
			   rt_mutex_t rt_mutex_create (const char* name, rt_uint8_t flag);



删除互斥量   ->系统不再使用互斥量时，通过删除互斥量以释放系统资源。删除互斥量使用下面的函数接口：

			   rt_err_t rt_mutex_delete (rt_mutex_t mutex);

			当删除一个互斥量时，所有等待此互斥量的线程都将被唤醒，等待线程获得的返回值是-RT_ERROR。然后系统将该互斥量从内核对
			象管理器链表中删除并释放互斥量占用的内存空间。
			   
			   

初始化互斥量 ->静态互斥量对象的内存是在系统编译时由编译器分配的，一般放于数据段或ZI段中。在使用这类静态互斥量对象前，需要先进行
			  初始化。初始化互斥量使用下面的函数接口：

			  rt_err_t rt_mutex_init (rt_mutex_t mutex, const char* name, rt_uint8_t flag);
			  
			  使用该函数接口时，需指定互斥量对象的句柄（即指向互斥量控制块的指针），互斥量名称以及互斥量标志。互斥量标志可用上面
			  创建互斥量函数里提到的标志。
			  
			  
			  
脱离互斥量   ->脱离互斥量将把互斥量对象从内核对象管理器中删除。脱离互斥量使用下面的函数接口：

			  rt_err_t rt_mutex_detach (rt_mutex_t mutex);

			  使用该函数接口后，内核先唤醒所有挂在该互斥量上的线程（线程的返回值是-RT_ERROR），然后系统将该互斥量从内核对象管理器链表中删除。
			  
			  
			  
获取互斥量   ->线程通过互斥量申请服务获取互斥量的所有权。线程对互斥量的所有权是独占的，某一个时刻一个互斥量只能被一个线程持有。
			  获取互斥量使用下面的函数接口：

			  rt_err_t rt_mutex_take (rt_mutex_t mutex, rt_int32_t time);
			  
			  如果互斥量没有被其他线程控制，那么申请该互斥量的线程将成功获得该互斥量。如果互斥量已经被当前线程线程控制，则该互斥量的持有计数
			  加1，当前线程也不会挂起等待。如果互斥量已经被其他线程占有，则当前线程在该互斥量上挂起等待，直到其他线程释放它或者等待时间超过指
			  定的超时时间。
			  
			  
			  
释放互斥量   ->当线程完成互斥资源的访问后，应尽快释放它占据的互斥量，使得其他线程能及时获取该互斥量。释放互斥量使用下面的函数接口：
			  rt_err_t rt_mutex_release(rt_mutex_t mutex);
			
			  使用该函数接口时，只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减1。当该互斥量的持有计数为零时（即
			  持有线程已经释放所有的持有操作），它变为可用，等待在该信号量上的线程将被唤醒。如果线程的运行优先级被互斥量提升，那么当互斥量被释放
			  后，线程恢复为持有互斥量前的优先级。
			  
			  

4.4.3 使用场合
======================================================================================================
互斥量的使用比较单一，因为它是信号量的一种，并且它是以锁的形式存在。在初始化的时候，互斥量永远都处于开锁的状态，而被线程持有的时候
则立刻转为闭锁的状态。互斥量更适合于：

1: -> 线程多次持有互斥量的情况下。这样可以避免同一线程多次递归持有而造成死锁的问题；

2: -> 可能会由于多线程同步而造成优先级翻转的情况；

3: -> 另外需要切记的是互斥量不能在中断服务例程中使用。


4.5	事件
======================================================================================================
事件主要用于线程间的同步，与信号量不同，它的特点是可以实现一对多，多对多的同步。

即一个线程可等待多个事件的触发：可以是其中任意一个事件唤醒线程进行事件处理的操作；也可以是几个事件都到达后才唤醒线程进行后续的处理；

同样，事件也可以是多个线程同步多个事件，这种多个事件的集合可以用一个32位无符号整型变量来表示，变量的每一位代表一个事件，线程通过“逻
辑与”或“逻辑或”与一个或多个事件建立关联，形成一个事件集。

事件的“逻辑或”也称为是独立型同步，指的是线程与任何事件之一发生同步；事件“逻辑与”也称为是关联型同步，指的是线程与若干事件都发生同步。

RT-Thread定义的事件有以下特点：
1 -> 事件只与线程相关，事件间相互独立：每个线程拥有32个事件标志，采用一个32 bit无符号整型数进行记录，每一个bit代表一个事件。若干个事
	 件构成一个事件集； 

2 -> 事件仅用于同步，不提供数据传输功能；

3 -> 事件无排队性，即多次向线程发送同一事件(如果线程还未来得及读走)，其效果等同于只发送一次。



在RT-Thread实现中，每个线程都拥有一个事件信息标记，它有三个属性，分别是RT_EVENT_FLAG_AND(逻辑与)，RT_EVENT_FLAG_OR(逻辑或）以及RT_EVENT_FLAG_CLEAR
(清除标记）。当线程等待事件同步时，可以通过32个事件标志和这个事件信息标记来判断当前接收的事件是否满足同步条件。




4.5.1 事件控制块
======================================================================================================

struct rt_event
{
		struct rt_ipc_object parent; /* 继承自ipc_object类*/
		rt_uint32_t set; /* 事件集合*/
};

/* rt_event_t是指向事件结构体的指针*/
typedef struct rt_event* rt_event_t;

rt_event对象从rt_ipc_object 中派生，由IPC容器管理。



4.5.2 事件相关接口
======================================================================================================
创建事件   -> 当创建一个事件时，内核首先创建一个事件控制块，然后对该事件控制块进行基本的初始化，创建事件使用下面的函数接口：
	
			 rt_event_t rt_event_create (const char* name, rt_uint8_t flag);

			 调用该函数接口时，系统会从动态内存堆中分配事件对象，然后进行对象的初始化，IPC对象初始化，并把set设置成0。
			 
			 

删除事件   -> 系统不再使用事件对象时，通过删除事件对象控制块来释放系统资源。删除事件可以使用下面的函数接口：

			 rt_err_t rt_event_delete (rt_event_t event);

			 在调用rt_event_delete函数删除一个事件对象时，应该确保该事件不再被使用。在删除前会唤醒所有挂起在该事件上的线程（线
			 程的返回值是-RT_ERROR），然后释放事件对象占用的内存块。
			 
			 
			
初始化事件 -> 静态事件对象的内存是在系统编译时由编译器分配的，一般放于数据段或ZI段中。在使用静态事件对象前，需要先行对它进行

			  初始化操作。初始化事件使用下面的函数接口： 

			  rt_err_t rt_event_init(rt_event_t event, const char* name, rt_uint8_t flag);
			  
			  调用该接口时，需指定静态事件对象的句柄（即指向事件控制块的指针），然后系统会初始化事件对象，并加入到系统对象容器中进行管理。
			  
			  

脱离事件   -> 脱离信号量是将事件对象从内核对象管理器中删除。脱离事件使用下面的函数接口：

			  rt_err_t rt_event_detach(rt_event_t event);
			  
			  用户调用这个函数时，系统首先唤醒所有挂在该事件等待队列上的线程（线程的返回值是- RT_ERROR ），然后将该事件从内核对象管理器中删除。
			  
			  

接受事件   -> 内核使用32位的无符号整型数来标识事件，它的每一位代表一个事件，因此一个事件对象可同时等待接收32个事件，内核可以通
			  过指定选择参数“逻辑与”或“逻辑或”来选择如何激活线程，使用“逻辑与”参数表示只有当所有等待的事件都发生时才激活
			  线程，而使用“逻辑或”参数则表示只要有一个等待的事件发生就激活线程。

			  接收事件使用下面的函数接口：
			  
			  rt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option,rt_int32_t timeout, rt_uint32_t* recved);
			  

发送事件   ->   通过发送事件服务，可以发送一个或多个事件。发送事件可以使用下面的函数接口：
			  
			  rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);


			  
4.5.3 使用场合
======================================================================================================
事件可使用于多种场合，它能够在一定程度上替代信号量，用于线程间同步。

一个线程或中断服务例程发送一个事件给事件对象，而后等待的线程被唤醒并对相应的事件进行处理。但是它与信号量不同的是，事件的发送操作在事件
未清除前，是不可累计的，而信号量的释放动作是累计的。事件另外一个特性是，接收线程可等待多种事件，即多个事件对应一个线程或多个线程。同时按
照线程等待的参数，可选择是“逻辑或”触发还是“逻辑与”触发。这个特性也是信号量等所不具备的，信号量只能识别单一的释放动作，而不能同时等待多种类型的释放。


各个事件类型可分别发送或一起发送给事件对象，而事件对象可以等待多个线程，它们仅对它们感兴趣的事件进行关注。当有它们感兴趣的事件发生时，线
程就将被唤醒并进行后续的处理动作。





4.6	邮箱
======================================================================================================
邮箱服务是实时操作系统中一种典型的任务间通信方法，特点是开销比较低，效率较高。邮箱中的每一封邮件只能容纳固定的4字节内容（针对32位处理系统
，指针的大小即为4个字节，所以一封邮件恰好能够容纳一个指针）。典型的邮箱也称作交换消息。

RT-Thread操作系统采用的邮箱通信机制有点类似于传统意义上的管道，用于线程间通讯。非阻塞方式的邮件发送过程能够安全的应用于中断服务中，是线程，
中断服务，定时器向线程发送消息的有效手段。

在一个线程向邮箱发送邮件时，如果邮箱没满，将把邮件复制到邮箱中。如果邮箱已经满了，发送线程可以设置超时时间，选择是否等待挂起或直接返回-RT_EFULL。
如果发送线程选择挂起等待，那么当邮箱中的邮件被收取而空出空间来时，等待挂起的发送线程将被唤醒继续发送的过程。

在一个线程从邮箱中接收邮件时，如果邮箱是空的，接收线程可以选择是否等待挂起直到收到新的邮件而唤醒，或设置超时时间。当设置的超时时间，邮箱依然未收
到邮件时，这个选择超时等待的线程将被唤醒并返回-RT_ETIMEOUT。如果邮箱中存在邮件，那么接收线程将复制邮箱中的4个字节邮件到接收线程中。




4.6.1 邮箱控制块
======================================================================================================
struct rt_mailbox
{                   
		struct rt_ipc_object parent;
		rt_uint32_t* msg_pool; /* 邮箱缓冲区的开始地址*/
		rt_uint16_t size; /* 邮箱缓冲区的大小*/
		rt_uint16_t entry; /* 邮箱中邮件的数目*/
		rt_uint16_t in_offset, out_offset; /* 邮箱缓冲的进出指针*/
		rt_list_t suspend_sender_thread; /* 发送线程的挂起等待队列*/
};

typedef struct rt_mailbox* rt_mailbox_t;
rt_mailbox对象从rt_ipc_object中派生，由IPC容器管理。



4.6.2 邮箱相关接口
======================================================================================================
创建邮箱	     -> 创建邮箱对象可以调用如下的函数接口：  
					rt_mailbox_t rt_mb_create (const char* name, rt_size_t size, rt_uint8_t flag);
					
					创建邮箱对象时会先创建一个邮箱对象控制块，然后给邮箱分配一块内存空间用来存放邮件，这块内存的大小等于邮件大小（4字节）与邮箱容量的乘积，接着
					初始化接收邮件和发送邮件在邮箱中的偏移量。


					
删除邮箱	      -> 当邮箱不再被使用时，应该删除它来释放相应的系统资源，一旦操作完成，邮箱将被永
					久性的删除。删除邮箱的函数接口如下： 
					rt_err_t rt_mb_delete (rt_mailbox_t mb);

					删除邮箱时，如果有线程被挂起在该邮箱对象上，内核先唤醒挂起在该邮箱上的所有线程（线程获得返回值是-RT_ERROR），然后再释放邮箱使用的内存，最后删除邮箱对象。
			
			

初始化邮箱	     -> 初始化邮箱跟创建邮箱类似，只是初始化邮箱用于静态邮箱对象的初始化。其他与创建邮箱不同的是，此处静态邮箱对象所使用的内存
					空间是由用户线程指定的一个缓冲区空间，用户把缓冲区的指针传递给邮箱对象控制块，其余的初始化工作与创建邮箱时相同。函数接
					口如下： 
					rt_err_t rt_mb_init(rt_mailbox_t mb, const char* name, void* msgpool,rt_size_t size, rt_uint8_t flag)

					初始化邮箱时，该函数接口需要获得用户已经申请获得的邮箱对象控制块，缓冲区的指针，以及邮箱名称和邮箱容量。					

					? 注： 这里的size参数指定的是邮箱的容量，即如果msgpool的字节数是N，那么邮箱容量应该是N/4。



脱离邮箱         ->  脱离邮箱将把邮箱对象从内核对象管理器中删除。脱离邮箱使用下面的接口：
					 rt_err_t rt_mb_detach(rt_mailbox_t mb);
					 
					使用该函数接口后，内核先唤醒所有挂在该邮箱上的线程（线程获得返回值是-RT_ERROR ），然后将该邮箱对象从内核对象管理器中删除。					 
					 
					 
					 
发送邮件	        ->  线程或者中断服务程序可以通过邮箱给其他线程发送邮件，发送邮件函数接口如下：
					rt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);

					发送的邮件可以是32位任意格式的数据，一个整型值或者一个指向缓冲区的指针。当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到-RT_EFULL 的返回值。
		
		

等待方式发送邮件 ->  用户也可以通过如下的函数接口向指定邮箱发送邮件：
					rt_err_t rt_mb_send_wait (rt_mailbox_t mb, rt_uint32_t value, rt_int32_t timeout);

					rt_mb_send_wait与rt_mb_send的区别在于，如果邮箱已经满了，那么发送线程将根据设定的timeout参数等待邮箱中因为收取邮件而空出空间。如果设置的超时时间到达依
					然没有空出空间，这是发送线程将被唤醒返回错误码。		
							
							
							
接收邮件	        ->  只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回RT_EOK的返回值，否则接收线程会根据超时时间设置，或挂起在邮
					箱的等待线程队列上，或直接返回。接收邮件函数接口如下：
					rt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t* value, rt_int32_t timeout);
					
					接收邮件时，接收者需指定接收邮件的邮箱句柄，并指定接收到的邮件存放位置以及最多能够等待的超时时间。如果接收时设定了超时，当指定的时间内依然未收到邮件时，将返
					回-RT_ETIMEOUT。

					
4.6.3 使用场合
======================================================================================================
邮箱是一种简单的线程间消息传递方式，在RT-Thread操作系统的实现中能够一次传递4字节邮件，并且邮箱具备一定的存储功能，能够缓存一定数量的邮件数(邮
件数由创建、初始化邮箱时指定的容量决定)。邮箱中一封邮件的最大长度是4字节，所以邮箱能够用于不超过4字节的消息传递，当传送的消息长度大于这个数目
时就不能再采用邮箱的方式。最重要的是，在32位系统上4字节的内容恰好适合放置一个指针，所以邮箱也适合那种仅传递指针的情况，例如：
struct msg
{
rt_uint8_t *data_ptr;
rt_uint32_t data_size;
};
对于这样一个消息结构体，其中包含了指向数据的指针data_ptr和数据块长度的变量data_size。

而在接收线程中，因为收取过来的是指针，而msg_ptr是一个新分配出来的内存块，所以在接收线程处理完毕后，需要释放相应的内存块：
struct msg* msg_ptr;
if (rt_mb_recv(mb, (rt_uint32_t*)&msg_ptr) == RT_EOK)
{
/* 在接收线程处理完毕后，需要释放相应的内存块*/
rt_free(msg_ptr);
}




4.7	消息队列
======================================================================================================
消息队列是另一种常用的线程间通讯方式，它能够接收来自线程或中断服务例程中不固定长度的消息，并把消息缓存在自己的内存空间中。其他线程也能够从消息队
列中读取相应的消息，而当消息队列是空的时候，可以挂起读取线程。当有新的消息到达时，挂起的线程将被唤醒以接收并处理消息。

消息队列是一种异步的通信方式。

通过消息队列服务，线程或中断服务例程可以将一条或多条消息放入消息队列中。同样，一个或多个线程可以从消息队列中获得消息。当有多个消息发送到消息队列时，
通常应将先进入消息队列的消息先传给线程，也就是说，线程先得到的是最先进入消息队列的消息，即先进先出原则(FIFO)。



4.7.1 消息队列控制块
======================================================================================================
struct rt_messagequeue
{
		struct rt_ipc_object parent;
		void* msg_pool; /* 存放消息的消息池开始地址*/
		rt_uint16_t msg_size; /* 每个消息的长度*/
		rt_uint16_t max_msgs; /* 最大能够容纳的消息数*/
		rt_uint16_t entry; /* 队列中已有的消息数*/
		void* msg_queue_head; /* 消息链表头*/
		void* msg_queue_tail; /* 消息链表尾*/
		void* msg_queue_free; /* 空闲消息链表*/
};
 
typedef struct rt_messagequeue* rt_mq_t;
rt_messagequeue对象从rt_ipc_object中派生，由IPC容器管理。




4.7.2 消息队列相关接口
======================================================================================================
创建消息队列     ->	消息队列在使用前，应该被创建出来，或对已有的静态消息队列对象进行初始化，创建消息队列的函数接口如下所示：
					rt_mq_t rt_mq_create(const char* name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag);

					创建消息队列时先创建一个消息队列对象控制块，然后给消息队列分配一块内存空间，组织成空闲消息链表，这块内存的大小等于[消息大小+消息头（用于链表连接）]与消息队
					列容量的乘积，接着再初始化消息队列，此时消息队列为空。
					
					

删除消息队列     -> 当消息队列不再被使用时，应该删除它以释放系统资源，一旦操作完成，消息队列将被永久性的删除。删除消息队列的函数接口如下：
					rt_err_t rt_mq_delete(rt_mq_t mq);

					删除消息队列时，如果有线程被挂起在该消息队列等待队列上，则内核先唤醒挂起在该消息等待队列上的所有线程（返回值是-RT_ERROR），然后再释放消息队列使用的内存，
					最后删除消息队列对象。
					
					
					
初始化消息队列   -> 初始化静态消息队列对象跟创建消息队列对象类似，只是静态消息队列对象的内存是在系统编译时由编译器分配的，一般放于数据段或
				   ZI段中。在使用这类静态消息队列对象前，需要进行初始化。初始化消息队列对象的函数接口如下：
					rt_err_t rt_mq_init(rt_mq_t mq, const char* name, void *msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag);

					初始化消息队列时，该接口需要获得消息队列对象的句柄（即指向消息队列对象控制块的指针）、消息队列名、消息缓冲区指针、消息大小以及消息队列容量。如图6-9所示，消
					息队列初始化后所有消息都挂在空闲消息列表上，消息队列为空。

					
					
脱离消息队列     -> 脱离消息队列将使消息队列对象被从内核对象管理器中删除。脱离消息队列使用下面的接口：
					rt_err_t rt_mq_detach(rt_mq_t mq);

					使用该函数接口后，内核先唤醒所有挂在该消息等待队列对象上的线程（返回值是-RT_ERROR ），然后将该消息队列对象从内核对象管理器中删除。

					
					
4.7.3 发送消息
======================================================================================================
线程或者中断服务程序都可以给消息队列发送消息。 

当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。
当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满。

发送消息的函数接口如下：
rt_err_t rt_mq_send (rt_mq_t mq, void* buffer, rt_size_t size);

发送消息时，发送者需指定发送到的消息队列的对象句柄（即指向消息队列控制块的指针），并且指定发送的消息内容以及消息大小。在发送一个普通消息之后，空闲消息链表
上的队首消息被转移到了消息队列尾。


发送紧急消息		-> 发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂
				   到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。
				   rt_err_t rt_mq_urgent(rt_mq_t mq, void* buffer, rt_size_t size);

				   				   
接收消息			-> 当消息队列中有消息时，接收者才能接收消息，否则接收者会根据超时时间设置或挂起在消息队列的等待线程队列上，或直接返回。
				   rt_err_t rt_mq_recv (rt_mq_t mq, void* buffer, rt_size_t size, rt_int32_t timeout);

	    		  接收消息时，接收者需指定存储消息的消息队列对象句柄，并且指定一个内存缓冲区，接收到的消息内容将被复制到该缓冲区里。此外，还需指定未能及时取到消息时的超时时
				  间。如图6-9所示，接收一个消息后消息队列上的队首消息被转移到了空闲消息链表的尾部。
				  
				  
4.7.4 使用场合
======================================================================================================
消息队列可以应用于发送不定长消息的场合，包括线程与线程间的消息交换，以及中断服务例程中发送给线程的消息（中断服务例程不可能接收消息）。


消息队列与邮箱的区别：
消息队列和邮箱的明显不同是消息的长度并不限定在4个字节以内，另外消息队列也包括了一个发送紧急消息的函数接口。但是当创建的是一个所有消息的最大长度是4字节的
消息队列时，消息队列对象将蜕化成邮箱。这个不限定长度的消息，也及时的反应到了代码编写的场合上，同样是类似邮箱的代码：


void message_handler()
{
struct msg msg_ptr; /* 用于放置消息的局部变量*/
/* 从消息队列中接收消息到msg_ptr中*/
if (rt_mq_recv(mq, (void*)&msg_ptr, sizeof(struct msg)) == RT_EOK)
{
/* 成功接收到消息，进行相应的数据处理*/
}
}

因为消息队列是直接的数据内容复制，所以在上面的例子中，都采用了局部变量的方式保存消息结构体，这样也就免去动态内存分配的烦恼了（也就不用担心，接收线程在接收到
消息时，消息内存空间已经被释放）。


同步消息：
在一般的系统设计中会经常遇到要发送同步消息的问题，这个时候就可以根据当时的状态选择相应的实现：两个线程间可以采用[消息队列+信号量]或邮箱的形式实现。

根据消息确认的不同，可以把消息结构体定义成：
struct msg
{
/* 消息结构其他成员*/
struct rt_mailbox ack;
};

/* 或者*/

struct msg
{
/* 消息结构其他成员*/
struct rt_semaphore ack;
};

第一种类型的消息使用了邮箱来作为确认标志，而第二种类型的消息采用了信号量来作为确认标志。邮箱做为确认标志，代表着接收线程能够通知一些状态值给发送线程；而信号
量作为确认标志只能够单一的通知发送线程，消息已经确认接收。




========================================================================================================================================================================================

第五章	内存管理
======================================================================================================
在计算系统中，变量、中间数据一般存放在系统存储空间中，只有在实际使用时才将它们从存储空间调入到中央处理器内部进行运算。

通常存储空间可以分为两种：内部存储空间和外部存储空间。

内部存储空间 -> 内部存储空间访问速度比较快，能够按照变量地址随机地访问，也就是我们通常所说的RAM（随机存储器），或电脑的内存。

外部存储空间 -> 而外部存储空间内所保存的内容相对来说比较固定，即使掉电后数据也不会丢失，这就是通常所讲的ROM（只读存储器），也可以把它理解为电脑的硬盘。


由于实时系统中对时间要求的严格性，内存分配往往要比通用操作系统要求苛刻得多：
1 -> 首先，分配内存的时间必须是确定的。
	 实时系统必须要保证内存块的分配过程在可预测的确定时间内完成，否则实时任务对外部事件的响应也将变得不可确定。

2 -> 其次，随着内存不断被分配和释放，整个内存区域会产生越来越多的碎片。
	 系统中还有足够的空闲内存，但因为它们地址并非连续，不能组成一块连续的完整内存块，会使得程序不能申请到大的内存。

3 -> 最后，嵌入式系统的资源环境也是不尽相同，有些系统的资源比较紧张，只有数十KB的内存可供分配，而有些系统则存在数MB的内存，如何为这些不同的系统，选择适合
	 它们的高效率的内存分配算法，就将变得复杂化。

	 
	 
RT-Thread操作系统在内存管理上，根据上层应用及系统资源的不同，有针对性的提供了不同的内存分配管理算法。	 
	 
总体上可分为两类：
1 -> 静态分区内存管理	 
	 
				   |->针对小内存块的分配管理（小内存管理算法）	
2 -> 动态内存管理->|	 
				   |->针对大内存块的分配管理（SLAB管理算法）
	 



5.1	静态内存池管理
======================================================================================================

5.1.1	静态内存池工作原理
======================================================================================================
内存池（Memory Pool）是一种用于分配大量大小相同的小对象技术。它可以极大加快内存分配/释放的速度。

内存池在创建时先向系统申请一大块内存，然后分成同样大小的多个小内存块，小内存块直接通过链表连接起来（此链表也称为空闲链表）。

内核负责给内存池分配内存池对象控制块，它同时也接收用户线程的分配内存块申请，当获得这些信息后，内核就可以从内存池中为内存池分配内存。

内存池一旦初始化完成，内部的内存块大小将不能再做调整。

静态内存池控制块
struct rt_mempool
{
	struct rt_object parent;
	void *start_address;/* 内存池数据区域开始地址*/
	rt_size_t size; /* 内存池数据区域大小*/
	rt_size_t block_size; /* 内存块大小*/
	rt_uint8_t *block_list; /* 内存块列表*/
	
	/* 内存池数据区域中能够容纳的最大内存块数*/
	rt_size_t block_total_count;

	/* 内存池中空闲的内存块数*/
	rt_size_t block_free_count;

	/* 因为内存块不可用而挂起的线程列表*/
	rt_list_t suspend_thread;

	/* 因为内存块不可用而挂起的线程数*/
	rt_size_t suspend_thread_count;
};
typedef struct rt_mempool* rt_mp_t;


每一个内存池对象由上述结构组成，其中suspend_thread形成了一个申请线程等待列表，即当内存池中无可用内存块时，并且申请线程允许等待，申请线程将挂起在suspend_thread链表上。
		

		
5.1.2	静态内存池接口
======================================================================================================

5.1.2.1	创建内存池
======================================================================================================
创建内存池   -> 创建内存池操作将会创建一个内存池对象并从堆上分配一个内存池。创建内存池是从对应内存池中分配和释放内存块的先决条件，创建
			   内存池后，线程便可以从内存池中执行申请、释放等操作。

			   创建内存池使用下面的函数接口，该函数返回一个已创建的内存池对象:
			   rt_mp_t rt_mp_create(const char* name, rt_size_t block_count, rt_size_t block_size);

			   使用该函数接口可以创建一个与需求的内存块大小、数目相匹配的内存池，前提当然是在系统资源允许的情况下（最主要的是动态堆内存资源）才能创建成功。创建内存池时，需
		要给内存池指定一个名称。然后内核从系统中申请一个内存池对象，然后从内存堆中分配一块由块数目和块大小计算得来的内存缓冲区，接着初始化内存池对象，并将申请成功的内存缓冲区组织成
		可用于分配的空闲块链表



5.1.2.2	删除内存池
======================================================================================================
删除内存池   -> 删除内存池将删除内存池对象并释放申请的内存。使用下面的函数接口：
			    rt_err_t rt_mp_delete(rt_mp_t mp);			  

				删除内存池时，会首先唤醒等待在该内存池对象上的所有线程（返回-RT_ERROR），然后再释放已从内存堆上分配的内存池数据存放区域，然后删除内存池对象。

				
				
5.1.2.3	初始化内存池
======================================================================================================
初始化内存池	-> 初始化内存池跟创建内存池类似，只是初始化内存池用于静态内存管理模式，内存池控制块来源于用户在系统中申请的静态对象。		  
			  
			   函数接口如下：
			   rt_err_t rt_mp_init(rt_mp_t mp, const char* name, void *start, rt_size_t size, rt_size_t block size);	

			   初始化内存池时，把需要进行初始化的内存池对象传递给内核，同时需要传递的还有内存池用到的内存空间，以及内存池管理的内存块数目和块大小，并且给内存池指定一个名
		称。这样，内核就可以对该内存池进行初始化，将内存池用到的内存空间组织成可用于分配的空闲块链表。+



5.1.2.4	脱离内存池
======================================================================================================
脱离内存池   -> 脱离内存池将把内存池对象从内核对象管理器中删除。脱离内存池使用下面的函数接口：
				rt_err_t rt_mp_detach(rt_mp_t mp);			   

				使用该函数接口后，内核先唤醒所有等待在该内存池对象上的线程，然后将内存池对象从内核对象管理器中删除。

				
				
5.1.2.5	分配内存块
======================================================================================================
分配内存块	 -> 从指定的内存池中分配一个内存块，使用如下接口：
				void *rt_mp_alloc (rt_mp_t mp, rt_int32_t time);
	
				如果内存池中有可用的内存块，则从内存池的空闲块链表上取下一个内存块，减少空闲块数目并返回这个内存块；如果内存池中已经没有空闲内存块，则判断超时时间设置：若超
		时时间设置为零，则立刻返回空内存块；若等待时间大于零，则把当前线程挂起在该内存池对象上，直到内存池中有可用的自由内存块，或等待时间到达。
				
		
		
5.1.2.6	释放内存块
======================================================================================================      
释放内存块   ->  任何内存块使用完后都必须被释放，否则会造成内存泄露，释放内存块使用如下接口：
				void rt_mp_free (void *block);
		
				使用该函数接口时，首先通过需要被释放的内存块指针计算出该内存块所在的（或所属于的）内存池对象，然后增加内存池对象的可用内存块数目，并把该被释放的内存块加入空
		闲内存块链表上。接着判断该内存池对象上是否有挂起的线程，如果有，则唤醒挂起线程链表上的首线程。


			   

5.2	动态内存管理
======================================================================================================
动态内存管理是一个真实的堆（Heap）内存管理模块，可以在当前资源满足的情况下，根据用户的需求分配任意大小的内存块。

而当用户不需要再使用这些内存块时，又可以释放回堆中供其他应用分配使用。

RT-Thread系统为了满足不同的需求，提供了两套不同的动态内存管理算法，分别是小堆内存管理算法和SLAB内存管理算法。

小堆内存管理算法 -> 小堆内存管理模块主要针对系统资源比较少，一般用于小于2M内存空间的系统。

SLAB内存管理算法 -> SLAB内存管理模块则主要是在系统资源比较丰富时，提供了一种近似多内存池管理算法的快速算法。


两种内存管理模块在系统运行时只能选择其中之一或者完全不使用动态堆内存管理器。这两种管理模块提供的API接口完全相同。


?警告：		因为动态内存管理器要满足多线程情况下的安全分配，会考虑多线程间的互斥问题，所以请不要在中断服务例程中分配或释放动态内存块。因为它可能会引起当前
			上下文被挂起等待。

		

5.2.1	小内存管理模块
======================================================================================================
小内存管理算法是一个简单的内存分配算法。初始时，它是一块大的内存。当需要分配内存块时，将从这个大的内存块上分割出相匹配的内存
块，然后把分割出来的空闲内存块还回给堆管理系统中。每个内存块都包含一个管理用的数据头，通过这个头把使用块与空闲块用双向链表的
方式链接起来。


释放时则是相反的过程，但分配器会查看前后相邻的内存块是否空闲，如果空闲则合并成一个大的空闲内存块。

内存管理的在表现主要体现在内存的分配与释放上

注意理解： 
图5.3: 小内存管理算法链表结构示意图

另外，在每次分配内存块前，都会留出12字节数据头用于magic，used信息及链表节点使用。返回给应用的地址实际上是这块内存块12字节以后的地址，前面的12字节数据头是用户永远不应该碰的部分。

释放时则是相反的过程，但分配器会查看前后相邻的内存块是否空闲，如果空闲则合并成一个大的空闲内存块。



5.2.2	SLAB内存管理模块
======================================================================================================
RT-Thread的SLAB分配器是在DragonFly BSD创始人Matthew Dillon实现的SLAB分配器基础上，针对嵌入式系统优化的内存分配算法。

RT-Thread的SLAB分配器实现主要是去掉了其中的对象构造及析构过程，只保留了纯粹的缓冲型的内存池算法。

下面是动态内存分配器主要的两种操作：
1 -> 内存分配 

2 -> 内存释放


5.2.3	动态内存接口
======================================================================================================

5.2.3.1	初始化系统堆空间
======================================================================================================
在使用堆内存时，必须要在系统初始化的时候进行堆内存的初始化，可以通过下面的函数接口完成：

void rt_system_heap_init(void* begin_addr, void* end_addr);

这个函数会把参数begin_addr，end_addr区域的内存空间作为内存堆来使用。



5.2.3.2	分配内存块
======================================================================================================
从内存堆上分配用户指定大小的内存块，函数接口如下：

void* rt_malloc(rt_size_t nbytes);

rt_malloc函数会从系统堆空间中找到合适大小的内存块，然后把内存块可用地址返回给用户。



5.2.3.3	重分配内存块
======================================================================================================
在已分配内存块的基础上重新分配内存块的大小（增加或缩小），可以通过下面的函数接口完成：

void *rt_realloc(void *rmem, rt_size_t newsize);

在进行重新分配内存块时，原来的内存块数据保持不变（缩小的情况下，后面的数据被自动截断）。



5.2.3.4	分配多内存块
======================================================================================================
从内存堆中分配连续内存地址的多个内存块，可以通过下面的函数接口完成：

void *rt_calloc(rt_size_t count, rt_size_t size);

返回的指针指向第一个内存块的地址，并且所有分配的内存块都被初始化成零。



5.2.3.5	释放内存块
======================================================================================================
用户线程使用完从内存分配器中申请的内存后，必须及时释放，否则会造成内存泄漏，释放内存块的函数接口如下：

void rt_free (void *ptr);

rt_free函数会把待释放的内存换回给堆管理器中。在调用这个函数时用户需传递待释放的内存块指针，结果是空指针直接返回。



5.2.3.6	设置分配钩子函数
======================================================================================================
在分配内存块过程中，用户可设置一个钩子函数，调用的函数接口如下：

void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size));

设置的钩子函数会在内存分配完成后进行回调。回调时，会把分配到的内存块地址和大小做为入口参数传递进去。



5.2.3.7	设置内存释放钩子函数
======================================================================================================
在释放内存时，用户可设置一个钩子函数，调用的函数接口如下：

void rt_free_sethook(void (*hook)(void *ptr));

设置的钩子函数会在调用内存释放完成前进行回调。回调时，释放的内存块地址会做为入口参数传递进去（此时内存块并没有被释放）。






========================================================================================================================================================================================

第六章	I/O设备管理
======================================================================================================
绝大部分的嵌入式系统都包括一些输入输出(I/O)设备。

在RT-Thread实时操作系统中，RT-Thread提供了一套简单的I/O设备管理框架，如RTThread I/O 设备结构所示，它把I/O设备分成了三层进行处理：

1 -> 应用程序     -> 通过RT-Thread的设备操作接口获得正确的设备驱动，然后通过这个设备驱动与底层I/O硬件设备进行数据（或控制）交互。

2 -> I/O设备管理  -> 实现了对设备驱动程序的封装。应用程序通过I/O设备模块提供的标准接口访问底层设备，设备驱动程序的升级、更替不会对上层应用产生影响。

3 -> 硬件外设


									一层			应用程序
									
												
													设备操作接口
									一层			设备对象容器
													串口驱动|SD卡驱动|网络驱动
										
											
									三层			硬件外设：串口|SD卡|以太网设备
			



RT-Thread提供给上层应用的是一个抽象的设备接口，给下层设备提供的是底层驱动框架。从系统整体位置来说I/O设备模块相当于设备驱动程序和上层应用之间的一个中间层。			

I/O设备模块实现了对设备驱动程序的封装。应用程序通过I/O设备模块提供的标准接口访问底层设备，设备驱动程序的升级、更替不会对上层应用产生影响。这种方式使得设备的
硬件操作相关的代码能够独立于应用程序而存在，双方只需关注各自的功能实现，从而降低了代码的耦合性、复杂性，提高了系统的可靠性。



6.1	块设备
======================================================================================================
在传统操作系统中一般将I/O设备分成字符设备、块设备和网络接口，分类的依据是设备数据与系统之间的传输处理方式。

1 -> 字符模式设备 -> 允许非结构的数据传输，即通常数据传输采用串行的形式，每次一个字节。字符设备通常是一些简单设备，如串口、按键。

2 -> 块设备       -> 每次传输一个数据块，例如每次传输512个字节数据。这个数据块是硬件强制性的，数据块可能使用某类数据接口或某些强制性的传输协议，否则
					就可能发生错误。


					
6.2	I/O设备控制块
======================================================================================================
struct rt_device
{

	/* balabalabalabala */

}



当前RT-Thread支持的设备类型包括：
enum rt_device_class_type
{

	/* balabalabalabala */

}

从设备控制块，我们可以看到，每个设备对象都会在内核中维护一个设备控制块结构，这种结构是使设备对象继承rt_object基类，然后形成rt_device设备类型。




6.3	I/O设备管理接口
======================================================================================================
6.3.1	注册设备
======================================================================================================
一个设备能够被上层应用访问前，需要先把这个设备注册到系统中，并添加一些相应的属性。

这些注册的设备均可以通过设备名，采用“查找设备接口”的方式来查找，从而获得该设备控制块（或设备句柄）。

注册设备的函数接口如下：
rt_err_t rt_device_register(rt_device_t dev, const char* name, rt_uint8_t flags);

flags参数支持下列参数(可以采用或的方式支持多种参数)：
#define RT_DEVICE_FLAG_DEACTIVATE 0x000 /* 未初始化设备*/
#define RT_DEVICE_FLAG_RDONLY 0x001 /* 只读设备*/
#define RT_DEVICE_FLAG_WRONLY 0x002 /* 只写设备*/
#define RT_DEVICE_FLAG_RDWR 0x003 /* 读写设备*/
#define RT_DEVICE_FLAG_REMOVABLE 0x004 /* 可移除设备*/
#define RT_DEVICE_FLAG_STANDALONE 0x008 /* 独立设备*/
#define RT_DEVICE_FLAG_ACTIVATED 0x010 /* 已激活设备*/
#define RT_DEVICE_FLAG_SUSPENDED 0x020 /* 挂起设备*/
#define RT_DEVICE_FLAG_STREAM 0x040 /* 设备处于流模式*/
#define RT_DEVICE_FLAG_INT_RX 0x100 /* 设备处于中断接收模式*/
#define RT_DEVICE_FLAG_DMA_RX 0x200 /* 设备处于DMA接收模式*/
#define RT_DEVICE_FLAG_INT_TX 0x400 /* 设备处于中断发送模式*/
#define RT_DEVICE_FLAG_DMA_TX 0x800 /* 设备处于DMA发送模式*/

? 警告：应当避免重复注册已经注册的设备，以及注册已有名字的设备驱动程序。



6.3.2	卸载设备
======================================================================================================
将设备从设备系统中卸载，被卸载的设备将不能再通过“查找设备接口”被查找到。

卸载设备的函数接口如下所示：
rt_err_t rt_device_unregister(rt_device_t dev)；

注： 卸载设备并不会释放设备控制块所占用的内存。



6.3.3	初始化所有设备
======================================================================================================
初始化所有注册到设备对象管理器中的未初始化的设备，可以通过如下函数接口完成：
rt_err_t rt_device_init_all(void)；

? 注：此函数将逐渐废弃，不推荐在应用程序中调用。



6.3.4	查找设备
======================================================================================================
根据指定的设备名称来查找设备，可以通过如下接口完成：
rt_device_t rt_device_find(const char* name)；

使用这个函数接口时，系统会在设备对象类型所对应的对象容器中遍历寻找设备对象，然后返回该设备，如果没有找到相应的设备对象，则返回RT_NULL。



6.3.5	打开设备
======================================================================================================
根据设备控制块来打开设备，可以通过如下函数接口完成：
rt_err_t rt_device_open (rt_device_t dev, rt_uint16_t oflags)；

其中oflags支持以下列表中的参数：
#define RT_DEVICE_OFLAG_RDONLY 0x001 /* 只读模式访问*/
#define RT_DEVICE_OFLAG_WRONLY 0x002 /* 只写模式访问*/
#define RT_DEVICE_OFLAG_RDWR 0x003 /* 读写模式访问*/

注： 如果设备flags域包含RT_DEVICE_FLAG_STANDALONE参数，将不允许重复打开。



6.3.6	关闭设备
======================================================================================================
根据设备控制块来关闭设备，可以通过如下函数接口完成：
rt_err_t rt_device_close(rt_device_t dev)；



6.3.7	读设备
======================================================================================================
根据设备控制块来读取设备，可以通过如下函数接口完成：
rt_size_t rt_device_read (rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size)；

根据底层驱动的实现，通常这个接口并不会阻塞上层应用线程。

函数返回
返回读到数据的实际大小(以字节为单位)；如果返回0，则需要读取当前线程的errno来判断错误状态。



6.3.8	写设备
======================================================================================================
根据设备控制块来写入设备，可以通过如下函数接口完成：
rt_size_t rt_device_write(rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size)；

根据底层驱动的实现，通常这个接口也不会阻塞上层应用线程。

函数返回
返回写入数据的实际大小(以字节为单位)；如果返回0，则需要读取当前线程的errno来判断错误状态



6.3.9	控制设备
======================================================================================================
根据设备控制块来控制设备，可以通过下面的函数接口完成：
rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void* arg)；



6.3.10	设置数据接收指示
======================================================================================================
设置一个回调函数，当硬件设备收到数据时回调以通知用程序有数据到达。可以通过如下函数接口完成设置接收指示：
rt_err_t rt_device_set_rx_indicate(rt_device_t dev, rt_err_t (*rx_ind )(rt_device_t dev,rt_size_t size))；

在调用这个函数时，回调函数rx_ind由调用者提供。当硬件设备接收到数据时，会回调这个函数并把收到的数据长度放在size参
数中传递给上层应用。上层应用线程应在收到指示后，立刻从设备中读取数据。



6.3.11	设置发送完成指示
======================================================================================================
在上层应用调用rt_device_write写入数据时，如果底层硬件能够支持自动发送，那么上层应用可以设置一个回调函数。

可以通过如下函数接口设置设备发送完成指示：

rt_err_t rt_device_set_tx_complete(rt_device_t dev, rt_err_t (*tx_done)(rt_device_t dev,void *buffer));

调用这个函数时，回调函数tx_done参数由调用者提供，当硬件设备发送完数据时，由驱动程序回调这个函数并把发送完成的数据
块地址buffer做为参数传递给上层应用。上层应用（线程）在收到指示时应根据发送buffer的情况，释放buffer内存块或将其做为
下一个写数据的缓存。



6.4	设备驱动
======================================================================================================
对于底层来说，如何编写一个设备驱动程序可能会更为重要，这节将详细描述如何编写一个设备驱动程序，并以STM32上的一个串口设备为例子进行说明。



6.4.1	设备驱动必须实现的接口
======================================================================================================
I/O设备模块提供的这六个接口（rt_device_init/open/read/write/control），对应到设备驱动程序的六个接口（driver_init/open/read/write/control等），可
以认为是底层设备驱动必须提供的接口：

方法名称							方法描述
init		->		设备的初始化。设备初始化完成后，设备控制块的flag会被置成已激活状态(RT_DEVICE_FLAG_ACTIVATED)。如果设备控制块的flag
					不是已激活状态，那么在设备框架调用rt_device_init_all接口时将调用此设备驱动的init接口进行设备初始化；如果设备控制块中的
					flag标志已经设置成激活状态，那么再运行初始化接口时，会立刻返回，而不会重新进行初始化。


open		->		打开设备。有些设备并不是系统一启动就已经打开开始运行； 或者设备需要进行数据接收，但如果上层应用还未准备好，设备也
					不应默认已经使能并开始接收数据。所以建议在写底层驱动程序时，应在调用open接口时才使能设备。


close		->		关闭设备。建议在打开设备时，设备驱动自行维护一个打开计数，在打开设备时进行+1操作，在关闭设备时进行-1操作， 当计数
					器变为0时，进行真正的关闭操作。


read		->		从设备中读取数据。参数pos指出读取数据的偏移量，但是有些设备并不一定需要指定偏移量，例如串口设备，设备驱动应忽略这
					个参数。而对于块设备来说，pos以及size都是以块设备的数据块大小做为单位的。



wrtie		->		向设备中写入数据。参数pos指出写入数据的偏移量。与读操作类似，对于块设备来说，pos以及size都是以块设备的数据块大小做
					为单位的。


control		->		根据不同的cmd命令控制设备。命令往往是由底层各类设备驱动自定义实现。



6.4.2	设备驱动实现的步骤
======================================================================================================
在实现一个RT-Thread设备时，可以按照如下的步骤进行（对于一些复杂的设备驱动，例如以太网接口驱动、图形设备驱动，请参看网络组件、GUI部分章节）：
1 -> 按照RT-Thread的对象模型，扩展一个对象有两种方式：

2 -> 定义自己的私有数据结构，然后赋值到RT-Thread设备控制块的user_data指针上；

3 -> 从struct rt_device结构中进行派生。

4 -> 实现RT-Thread I/O设备模块中定义的6个公共设备接口，开始可以是空函数(返回类型是rt_err_t的可默认返回RT_EOK)；

5 -> 根据自己的设备类型定义自己的私有数据域。

6 -> 根据设备的类型，注册到RT-Thread设备框架中。



6.4.3	STM32F103的串口驱动
======================================================================================================



========================================================================================================================================================================================

第七章	异常与中断
======================================================================================================
异常是导致处理器脱离正常运行转向执行特殊代码的任何事件，如果不及时进行处理，轻则系统出错，重则会导致系统毁灭性地瘫痪。

所以正确地处理异常，避免错误的发生是提高软件鲁棒性（稳定性）非常重要的一环，对于实时系统更是如此。


异常通常可以分成两类：同步异常和异步异常。
同步异常 -> 主要是指由于内部事件产生的异常，例如除零错误。

异步异常 -> 异步异常主要是指由于外部异常源产生的异常，例如按下设备某个按钮产生的事件。

同步异常与异步异常的区别还在于:
同步异常触发后，系统必须立刻进行处理而不能够依然执行原有的程序指令步骤；而异步异常则可以延缓处理甚至是忽略，例如按键中断异常，虽然中断异常触发
了，但是系统可以忽略它继续运行（同样也忽略了相应的按键事件）。

中断，通常也叫做外部中断，中断属于异步异常。当中断源产生中断时，处理器也将同样陷入到一个固定位置去执行指令。



7.1	中断处理过程
======================================================================================================
当中断产生时，处理机将按如下的顺序执行：

1 -> 保存当前处理机状态信息

2 -> 载入异常或中断处理函数到PC寄存器

3 -> 把控制权转交给处理函数并开始执行

4 -> 当处理函数执行完成时，恢复处理器状态信息

5 -> 从异常或中断中返回到前一个程序执行点

中断使得CPU可以在事件发生时才予以处理，而不必让CPU连续不断地查询是否有相应的事件发生。

在执行中断服务例程的过程中，如果有更高优先级别的中断源触发中断，由于当前处于中断处理上下文环境中，根据不同的处理器构架可能有不同的处理方式，

比如新的中断等待挂起直到当前中断处理离开后再行响应；或新的高优先级中断打断当前中断处理过程，而去直接响应这个更高优先级的新中断源。
后面这种情况，称之为中断嵌套。

在硬实时环境中，前一种情况是不允许发生的，不能响应中断的时间应尽量的短。而在软件处理（软实时环境）上，RT-Thread允许中断嵌套，即在一个中断服
务例程期间，处理器可以响应另外一个优先级更高的中断。



7.2	中断栈
======================================================================================================
在系统响应中断前，软件代码（或处理器）需要把当前任务的上下文保存下来（通常保存在当前任务的任务栈中），再调用中断服务例程进行中断响应、处理。
在进行中断处理时（实质是调用用户的中断服务例程函数），中断处理函数中很可能会有自己的局部变量，这些都需要相应的栈空间来保存，所以中断响应依然
需要一个栈空间来做为上下文运行中断处理函数。


RT-Thread采用的方式是提供独立的中断栈，即中断发生时，中断的前期处理程序会将用户的栈指针更换到系统事先留出的中断栈空间中，等中断退出时再恢复用
户的栈指针。这样中断就不会占用任务的栈空间，从而提高了内存空间的利用率，且随着任务的增加，这种减少内存占用的的效果也越明显。



7.3	中断的底半处理
======================================================================================================
RT-Thread不对中断服务例程所需要的处理时间做任何假设、限制，但如同其它实时操作系统或非实时操作系统一样，用户需要保证所有的中断服务例程在尽可能
短的时间内完成（相当于中断服务例程在系统中拥有最高的优先级，会抢占所有线程优先执行）。



7.3.1	底半处理实现范例
======================================================================================================




7.4	中断相关接口
======================================================================================================
为了尽量的使用户和系统底层异常、中断隔离开来，RT-Thread把中断和异常封装起来，以更友好的接口的形式提供给用户。



7.4.1	装载中断服务例程
======================================================================================================
可调用如下的接口挂载一个新的中断服务例程：
rt_isr_handler_t rt_hw_interrupt_install(int vector,rt_isr_handler_t handler,void *param,char *name);



7.4.2	屏蔽中断源
======================================================================================================
通常在ISR准备处理某个中断信号之前，我们需要先屏蔽该中断源，以保证在接下来的处理过程中硬件状态或者数据不会受到干扰，我们可调用下面这个函数接口：
void rt_hw_interrupt_mask(int vector);

注意事项：
这个API并不会出现在每一个移植分支中，例如通常Cortex-M0/M3/M4的移植分支中就没有这个API。


7.4.3	打开被屏蔽的中断源
======================================================================================================
在ISR处理完状态或数据以后，需要及时的打开之前被屏蔽的中断源，使得尽可能的不丢失硬件中断信号，我们可调用下面的函数接口：
void rt_hw_interrupt_umask(int vector);

注意事项：
这个API并不会出现在每一个移植分支中，例如通常Cortex-M0/M3/M4的移植分支中就没有这个API。


7.4.4	关闭中断
======================================================================================================
当需要关闭整个系统的中断时，可调用下面的函数接口：
rt_base_t rt_hw_interrupt_disable(void);

当系统关闭了中断时，就意味着当前任务/代码不会被其他事件所打断（因为整个系统已经不再对外部事件响应），也就是当前任务不会被抢占，除非这个任务主动
让出处理器。



7.4.5	打开中断
======================================================================================================
打开中断往往是和关闭中断成对使用的，用于恢复关闭中断前的状态。

调用的函数接口如下：
void rt_hw_interrupt_enable(rt_base_t level);



7.4.6	与OS相关的中断接口
======================================================================================================
当整个系统被中断打断，进入中断处理函数时，OS需要知道当前已经进入到中断状态。

针对这种情况，OS提供了两个函数：

void rt_interrupt_enter(void);
void rt_interrupt_leave(void);



7.5	ARM Cortex-M中的中断与异常
======================================================================================================
ARM Cortex-M系列处理器与以往的ARM7TDMI、ARM920T相差很多，以往中断控制器都由IP授权的各家芯片厂商自行定义，而ARM Cortex-M则把中断控制器统一起来，命
名为NVIC（嵌套向量中断控制）。

正如其名，ARM Cortex-M NVIC支持中断嵌套功能，这些部分上下文寄存器保存到中断栈的行为完全是硬件行为，这一点是与其他ARM处理器最大的区别（以往都需要依
赖于软件保存上下文）。

另外，在ARM Cortex-M系列处理器上，所有中断都采用中断向量表的方式进行处理，即当一个中断触发时，处理器将直接判定是哪个中断源，然后直接跳转到相应的固定位
置进行处理。

而在ARM7、ARM9中，一般是先跳转进入IRQ入口，然后再由软件进行判断是哪个中断源触发，获得了相对应的中断服务例程入口地址后，再进行后续的中断处理。

ARM7、ARM9的好处在于，所有中断它们都有统一的入口地址，便于OS的统一管理。而ARM Cortex-M系列处理器则恰恰相反，每个中断服务例程必须排列在一起放在统一的地
址上（这个地址必须要设置到NVIC的中断向量偏移寄存器中）。



7.6	外设中的中断模式与轮询模式
======================================================================================================
当编写一个外设驱动时，其编程模式到底采用中断模式触发还是轮询模式触发往往是驱动开发人员首先要考虑的问题，并且这个问题在实时操作系统与分时操作系统中差异还非常
大。

因为轮询模式本身采用顺序执行的方式：查询到相应的事件然后进行对应的处理。所以轮询模式从实现上来说，相对简单清晰。

但是在实时系统中轮询模式可能会出现非常大问题，因为在实时操作系统中，当一个程序持续地执行时（轮询时），它所在的线程会一直运行，比它优先级低的线程都不会得到运
行。

所以通常情况下，实时系统中更多采用的是中断模式来驱动外设。当数据达到时，由中断唤醒相关的处理线程，再继续进行后续的动作。


我们可以看出其中的一些关键因素：发送数据量越小，发送速度越快，对于数据吞吐量的影响也将越大。归根结底，系统中产生中断的频度如何。当一个实时系统想要提升数据吞
吐量时，可以考虑的几种方式：
1 -> 增加每次数据量发送的长度，每次尽量让外设尽量多地发送数据； 

2 -> 必要情况下更改中断模式为轮询模式。同时为了解决轮询方式一直抢占处理机，其他低优先级线程得不到运行的情况，可以把轮询线程的优先级适当降低。



========================================================================================================================================================================================

第8章	应用模块
======================================================================================================
在传统桌面操作系统中，用户空间和内核空间是分开的，应用程序运行在用户空间，内核以及内核模块则运行于内核空间

在小型嵌入式设备领域，通常并不区分内核态与用户态，并且整个系统通常编译成一个单独的固件下载到单片机芯片的Flash中。	
	
自RT-Thread 0.4.0版开始引入了一种称为RT-Threadapplication module（应用模块）的技术，它提供了一种动态加载或卸载应用程序的功能，
应用程序可以独立编译，并存储外部存储介质上，如SD卡、SPI Flash，甚至可以通过网络传输	。

但RT-Thread依然没有区分用户空间与内核空间，应用模块兼顾应用程序和内核模块的属性，是两者的结合体，所以称作应用模块。
	
	
	
8.1	功能和限制
======================================================================================================
应用模块为RT-Thread提供一种类似桌面系统安装卸载应用程序的功能，功能十分灵活。从实现上讲，这是一种将内核和应用分开的机制，通过
这种机制，内核和应用可以分开编译，并在运行时通过内核中的模块加载器将编译好的应用加载到内核中运行。



8.2	使用应用模块
======================================================================================================
要想在板子测试使用应用模块，需要编译一个支持应用模块的RT-Thread主程序以及独立编译的应用模块程序。下面将分为两部分介绍。


	 
8.2.1	编译主程序
======================================================================================================
在rtconfig.h中打开如下宏（如果不存在则手动添加）
RT_USING_MODULE
然后重新编译主工程。


8.2.2	使用应用模块
======================================================================================================

8.3	应用模块API
======================================================================================================
除了可以通过finsh手动加载应用模块外，也可以在主程序中使用RT-Thread提供的应用模块API来加载或卸载应用模块。

rt_module_t rt_module_open(const char *path)
这个函数从文件系统中加载应用模块到内存中运行，若正确加载返回该模块的指针。

rt_module_t rt_module_find(const char *name)
这个函数根据模块名查找系统已加载的模块，若找到返回该模块的指针。

rt_err_t rt_module_destroy(rt_module_t module)
这个函数会销毁应用模块占用的RT-Thread内核对象，如信号量、互斥量、mempool等，如果它使用了的话。

rt_err_t rt_module_unload(rt_module_t module)
这个函数会销毁应用模块的线程以及子线程。




========================================================================================================================================================================================

第10章	SCons构建系统
======================================================================================================
SCons是一套由Python语言编写的开源构建系统，类似于GNU Make。它采用不同于通常Makefile文件的SConstruct和SConscript文件。这些
文件也是Python脚本，能够使用标准的Python语法来编写。所以在SConstruct、SConscript文件中可以调用Python标准库进行各类复杂的处
理，而不局限于Makefile设定的规则。

在SCons的网站上可以找到详细的SCons用户手册，本章节讲述SCons的基本用法，以及如何在RT-Thread中用好SCons工具。



10.1	什么是构建工具(software construction tool)
======================================================================================================
构建工具是一种软件，它可以根据一定的规则或指令，将源代码编译成可执行的二进制程序，这是构建工具最基本也是最重要的功能。

实际上，构建工具的功能不至于此，通常这些规则有一定的语法，并组织成文件。这些文件用于来控制构建工具的行为，在完成软件构
建之外，也可以做其他事情。

目前最流行的构建工具是Make。很多知名开源软件，如Linux内核就采用Make构建。Make通过读取Makefile文件来检测文件的组织结构和
依赖关系，并完成Makefile中所指定的命令。

由于历史原因，Makefile的语法比较混乱,不利于初学者学习。此外，在Windows平台上使用Make也不方便，需要安装Cygwin环境。为了克
服Make的种种缺点，人们开发了其他构建工具，如CMak和SCons等。



10.2	RT-Thread构建
======================================================================================================
RT-Thread早期使用Make/Makefile构建。从0.3.x开始，RT-Thread开发团队逐渐引入了SCons构建系统，引入SCons唯一的目是：使大家从复
杂的Makefile配置、IDE配置中脱离出来，把精力集中在RT-Thread功能开发上。


有些读者可能会有些疑惑，这里介绍的构建工具有IDE有什么不同？

通常IDE有自己的管理源码的方式，一些IDE使用XML来组织文件，并解决依赖关系。大部分IDE会根据用户所添加的源码生成类似Makefile与
SConscript的脚本文件，在底层调用类似Make与SCons的工具来构建源码。IDE通过可以图形化的操作来完成构建。



========================================================================================================================================================================================

第11章	finsh shell
======================================================================================================
11.1	简介
======================================================================================================
finsh是RT-Thread的命令行外壳（shell），提供一套供用户在命令行的操作接口，主要用于调试、查看系统信息。

finsh支持两种模式：
1 -> C语言解释器模式, 为行文方便称之为c-style；

2 -> 传统命令行模式，此模式又称为msh(module shell)。

C语言表达式解释模式下, finsh能够解析执行大部分C语言的表达式，并使用类似C语言的函数调用方式访问系统中的函数及全局变量，此外它也能够通过命令行方式创建变量。




11.2	工作模式
======================================================================================================
外界由设备端口输入命令行，finsh 通过对设备输入的读取，解析输入内容，然后自动扫描内部两个段，寻找对应函数名，输出回应。


11.3	什么是shell?
======================================================================================================
人机交互的需要。

计算机先驱们开发了一种软件，它接受用户输入的命令，解释之后，传递给操作系统，并将操作系统执行的结果返回给用户。这个程序像一层外壳包裹在操作系统的外面，所以
它被称为shell。

对于一般人来说，shell的光彩逐渐暗淡，它并未因此退出操作系统。在windows上，CMD可以认为就是一种shell。


11.4	初始finsh
======================================================================================================
在大部分嵌入式系统中，一般开发调试都使用硬件调试器和printf日志打印，在有些情况下，这两种方式并不是那么好用。

比如对于RT-Thread这个多线程系统，我们想知道某个时刻系统中的线程运行状态、手动控制系统状态。如果有一个shell，就可以输入命令，直接相应的函数执行获得需要的信
息，或者控制程序的行为。这无疑会十分方便。


11.4.1	finsh（C-Style）
======================================================================================================
嵌入式设备通常采用交叉编译，一般需要将开发板与PC机连接起来通讯，常见连接方式包括，串口、USB、以太网、wifi等。一个灵活的shell应该可以在多种连接方式上工作。
 
finsh正是基于这些考虑而诞生的。finsh运行于开发板，它可以使用串口/以太网/USB等与PC机进行通信。


11.4.2	finsh(msh)
======================================================================================================

11.4.3	finsh中的按键
======================================================================================================
  
11.5	finsh特性
======================================================================================================

11.5.1	finsh(C-Sytle)的数据类型
======================================================================================================
finsh支持基本的C语言数据类型，包括：

数据类型									描述
void 							空数据格式，只用于创建指针变量
char, unsigned char 			（带符号）字符型变量
int, unsigned int 				（带符号）整数型变量
short, unsigned short 			（带符号）短整型变量
long, unsigned long 			（带符号）长整型变量
char, short, long, void			 指针型变量

在finsh的命令行上，输入上述数据类型的C表达式可以被识别。浮点类型以及复合数据类型unin与struct等暂不支持。此外，finsh也不支持for，while，跳转语句goto。



11.6	finsh(C-Sytle)中增加命令/变量
======================================================================================================

11.6.1	宏方式
======================================================================================================

11.6.2	函数方式
======================================================================================================

11.7	finsh(msh)中增加命令
======================================================================================================
11.7.1	添加内置命令
======================================================================================================

11.8	RT-Tread内置命令
======================================================================================================

11.8.1	finsh(c-style)
======================================================================================================

11.8.2	finsh(msh)内置命令
======================================================================================================
要查看命令行信息必须定义对应相应的宏。
finsh>>list()
显示当前系统中存在的命令及变量，执行结果如下：

--Function List:
list_mem -- list memory usage information
hello -- say hello world
version -- show RT-Thread version information
list_thread -- list thread						//显示当前系统中线程状态：
list_sem -- list semaphone in system			//显示系统中信号量状态
list_event -- list event in system				//显示系统中事件状态
list_mutex -- list mutex in system				//显示系统中互斥量状态
list_mailbox -- list mail box in system			//显示系统中信箱状态:
list_magqueue -- list messgae queue in system	//显示系统中消息队列状态
list_mempool -- list memory pool in system		//显示系统中内存池状态
list_timer -- list timer in system				//显示系统中定时器状态
list_device -- list device in system			//显示系统中设备状态
list -- list all symbol in system
--Variable List:
dummy -- dummy variable for finsh
0, 0x00000000



11.9	移植
======================================================================================================

11.10	宏选择
======================================================================================================


========================================================================================================================================================================================

第12章	文件系统
======================================================================================================
12.1	简介
======================================================================================================
RT-Thread 的文件系统采用了三层的结构：

参考图12.1: 文件系统结构图


一层：最顶层的是一套面向嵌入式系统，专门优化过的虚拟文件系统（接口）。通过它，RTthread操作系统能够适配下层不同的文件系统格式

二层：接下来中间的一层是各种文件系统的实现

三层：最底层的是各类存储驱动，例如SD 卡驱动，IDE 硬盘驱动等

RT-Thread 的文件系统对上层提供的接口主要以POSIX 标准接口为主，这样也能够保证程序可以在PC 上编写、调试，然后再移植到RT-Thread 操作系统上。



12.2	文件系统、文件与文件夹
======================================================================================================
文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型(Abstract data type)，是一种用于向用户提供底层数据访问的机制。文件
系统通常存储的基本单位是文件，即数据是按照一个个文件的方式进行组织。当文件比较多时，将导致文件繁多，不易分类、重名的问题。而文件夹作为一个
容纳多个文件的容器而存在。

在RT-Thread 中，文件系统名称使用上类似UNIX 文件、文件夹的风格，参考图12.2: 目录结构

在RT-Thread 操作系统中，文件系统有统一的根目录，使用’/’来表示。而在根目录下的f1.bin 文件则使用’/f1.bin’来表示，2011 目录下的f1.bin目录则使
用’/data/2011/f1.bin’来表示。即目录的分割符号是’/’，这与UNIX/Linux 完全相同的，与Windows 则不相同



12.3	文件系统接口
======================================================================================================
12.3.1	打开文件
======================================================================================================
打开或创建一个文件可以调用下面的open 函数接口：
int open(const char *pathname, int oflag, int mode);



12.3.2	关闭文件
======================================================================================================
当使用完文件后若不再需要使用则可使用close()函数接口关闭该文件，而close()会让数据写回磁盘，并释放该文件所占用的资源。关闭文件的函数接口如下：
int close(int fd);



12.3.3	读取数据
======================================================================================================
读取数据可使用下面的函数接口：
size_t read(int fd, void *buf, size_t count);



12.3.4	写入数据
======================================================================================================
写入数据可使用下面的函数接口：
size_t write(int fd, const void *buf, size_t count);



12.3.5	更改名称
======================================================================================================
更改文件的名称可使用下面的函数接口：
int rename(const char *oldpath, const char *newpath);

rename()会将参数oldpath 所指定的文件名称改为参数newpath 所指的文件名称。若newpath 所指定的文件已经存在，则该文件将会被覆盖。



12.3.6	取得状态
======================================================================================================
获取文件状态可使用下面的stat 函数接口：
int stat(const char *file_name, struct stat *buf);

stat()函数用来将参数file_name 所指向的文件状态，复制到buf 指针所指的结构中(struct stat)。



12.4	目录操作接口
======================================================================================================
12.4.1	创建目录
======================================================================================================
创建目录可使用下面的函数接口：
int mkdir(const char *path, mode_t mode);

mkdir()函数用来创建一个目录，参数path 为目录名，参数mode 在当前版本未启用，输入0x777 即可。



12.4.2	打开目录
======================================================================================================
打开目录可使用下面的函数接口：
DIR* opendir(const char* name);

opendir()函数用来打开一个目录，参数name 为目录路径名。若读取目录成功，返回该目录结构，若读取目录失败，返回RT_NULL。



12.4.3	读取目录
======================================================================================================
读取目录可使用下面的函数接口：
struct dirent* readdir(DIR *d);

readdir()函数用来读取目录，参数d 为目录路径名。返回值为读到的目录项结构，如果返回值为RT_NULL，则表示已经读到目录尾；
此外，每读取一次目录，目录流的指针位置将自动往后递推1 个位置。



12.4.4	取得目录流的读取位置
======================================================================================================
获取目录流的读取位置可使用下面的函数接口：
off_t telldir(DIR *d);



12.4.5	设置下次读取目录的位置
======================================================================================================
设置下次读取目录的位置可使用下面的函数接口：
void seekdir(DIR *d, off_t offset);



12.4.6	重设读取目录的位置为开头位置
======================================================================================================
重设读取目录为开头位置可使用下面的函数接口：
void rewinddir(DIR *d);



12.4.7	关闭目录
======================================================================================================
关闭目录可使用下面的函数接口：
int closedir(DIR* d);

closedir()函数用来关闭一个目录。该函数必须和opendir()函数成对出现。



12.4.8	删除目录
======================================================================================================
删除目录可使用下面的函数接口：
int rmdir(const char *pathname);



12.4.9	格式化文件系统
======================================================================================================
int mkfs(const char * fs_name, const char * device)



12.5	底层驱动接口
======================================================================================================
RT-Thread DFS 文件系统针对下层媒介使用的是RT-Thread 的设备IO系统，其中主要包括设备读写等操作。但是有些文件系统并不依赖
于RT-Thread 的设备系统，例如1.0.x分支引入的只读文件系统、网络文件系统等。对于常使用的FAT 文件系统，下层驱动必须用块设备
的形式来实现。



12.5.1	文件系统初始化
======================================================================================================
在使用文件系统接口前，需要对文件系统进行初始化，代码如下：

#ifdef RT_USING_DFS
/* 包含DFS 的头文件*/
#include <dfs_fs.h>
#include <dfs_elm.h>
#endif
/* 初始化线程*/
void rt_init_thread_entry(void *parameter)
{
	/* 文件系统初始化*/
	#ifdef RT_USING_DFS
	{
	/* 初始化设备文件系统*/
	dfs_init();
	#ifdef RT_USING_DFS ELMFAT
	/* 如果使用的是ELM 的FAT 文件系统，需要对它进行初始化*/
	elm_init();
	/* 调用dfs_mount 函数对设备进行装载*/
	if (dfs_mount("sd0", "/", "elm", 0, 0) == 0)
	rt_kprintf("File System initialized!\n");
	else
	rt_kprintf("File System init failed!\n");
	#endif
	}
	#endif
}

其主要包括的函数接口为：
int dfs_mount(const char* device_name, const char* path, const char* filesystemtype,
rt_uint32_t rwflag, const void* data);



12.6	FatFs
======================================================================================================
FatFs是专为小型嵌入式设备开发的一个兼容微软fat的文件系统，采用ANSI C编写，采用抽象的硬件I/O层，因此具有良好的硬件无关性以及可移植性。

FatFs官方网址http://elm-chan.org/fsw/ff/00index_e.html

RT-Thread将FatFs整合为一个RT-Thread组件，并置于DFS层之下。因此可以非常方便的在RT-Thread中使用FatFs。



12.6.1	FatFs相关宏
======================================================================================================
/* DFS: ELM FATFS options */
#define RT_USING_DFS_ELMFAT

在RT-Thread中使用Elm FatFs，需要在rtconfig.h打开此宏。


/* Maximum sector size to be handled. */
#define RT_DFS_ELM_MAX_SECTOR_SIZE 512

指定FatFs的内部扇区大小，注意，这个宏需要与实际硬件驱动的扇区大小一致。例如，某spi flash芯片扇区为4096字节，则上述宏需要修改为4096，否
则FatFs从驱动读入数据时就会发生数组越界而导致系统崩溃。


/* Number of volumes (logical drives) to be used. */
#define RT_DFS_ELM_DRIVES 2
FatFs支持多分区，默认支持一个分区，如果想要在多个设备上挂载FatFs，可以修改上述宏定义。


/* Reentrancy (thread safe) of the FatFs module. */
#define RT_DFS_ELM_REENTRANT
Elm FatFs充分考虑了多线程安全读写安全的情况，当在多线程中读写FafFs时，为了避免重入带来的问题，需要打开上述宏。如果系统仅有一个线程操作文
件系统，不会出现重入问题，则可以关闭上述宏以节省资源。



12.7	NFS
======================================================================================================
NFS是Network File System（网络文件系统）的简称。NFS允许一个系统在网络上与他人共享目录和文件。通过NFS，用户和程序可以像访问本地文件一样访
问远端系统上的文件。NFS可以加速程序的开发调试，在嵌入式系统中应用十分广泛。

NFS主要由部分组成：一台服务器和一台或多台客户机。客户机远程访问存放在服务器上的资源。

PC上运行NFS server程序，运行RT-Thread的嵌入式系统做NFS Client，可以将PC上的目录通过以太网络挂载到RT-Thread中。



12.7.1	RT-Thread中使用NFS
======================================================================================================
NFS通过以太网实现数据传输，因此要想在RT-Thread中使用NFS，需要一些基本条件：
? 开发板硬件带有以太网支持
? 以太网驱动测试通过，可以在RT-Thread中正确运行Lwip
当具备这两个条件，我们就可以在RT-Thread上使用NFS了。


主机配置:
Windows上可以使用FreeNFS搭建一个简单的NFS Server。

开发板配置:
需要在rtconfig.h中开DFS以及LWIP，并根据开发板的网络环境修改网络配置，并确保PC机与开发板可以正常ping通。

#define RT_USING_LWIP
#define RT_LWIP_IPADDR0 192
#define RT_LWIP_IPADDR1 168
#define RT_LWIP_IPADDR2 1
#define RT_LWIP_IPADDR3 30
/* gateway address of target*/
#define RT_LWIP_GWADDR0 192
#define RT_LWIP_GWADDR1 168
#define RT_LWIP_GWADDR2 1
#define RT_LWIP_GWADDR3 1
/* mask address of target*/
#define RT_LWIP_MSKADDR0 255
#define RT_LWIP_MSKADDR1 255
#define RT_LWIP_MSKADDR2 255
#define RT_LWIP_MSKADDR3 0
#define RT_USING_DFS_NFS

NFS属于DFS组件，因此同样需要打开DFS宏，以及DFS_NFS宏，并配置RT_NFS_HOST_EXPORT宏。

#define RT_USING_DFS
#define RT_USING_DFS_NFS
#define RT_NFS_HOST_EXPORT "192.168.1.2:/"

上述代码可以分为两部分，第一部分是初始化lwip组件。第二部分包括NFS初始化，以及挂在NFS Server上的共享目录。示例代码中
将NFS挂载到了系统根目录下， 读者也可以选择其他文件系统挂在根目录，并将NFS挂载到其他子路径下。



12.8	UFFS
======================================================================================================
UFFS是Ultra-low-cost Flash File System（超低功耗的闪存文件系统）的简称。它是国人开发的、专为嵌入式设备等小内存环境中
使用Nand Flash的开源文件系统。与嵌入式中常使用的yaffas文件系统相比具有资源占用少、启动速度快、免费等优势。

UFFS官方代码仓库http://sourceforge.net/projects/uffs/

	

12.8.1	UFFS配置
======================================================================================================
首先来介绍rtconfig.h中的UFFS中的相关宏。	

#define RT_USING_MTD_NAND
#define RT_USING_DFS
#define RT_USING_DFS_UFFS

在RT-Thread中的UFFS使用了MTD NAND的接口，因此需要打开RT_USING_MTD_NAND。此外，要想正确使用UFFS还必须提供NAND的驱动程序，
它需要符合RT-Thread的MTDNAND接口规范。该驱动程序的实现将在后面的章节介绍。后面两个宏必须打开。

更多配置参考dfs_uffs.h与uffs_config.h

UFFS配置相关宏。在nand flash芯片上通常使用ECC进行数据校验（ECC是一种数据校
验与纠错机制）。UFFS支持多种校验方式，包括如下几种：
1. UFFS_ECC_SOFT 		->	软件校验方式，主要用于一些不支持硬件ECC的的情况下，ECC校验由UFFS完成。由于ECC数据校验比较耗时，因此这种方式
							会导致读写速度降低，不推荐使用。

2. UFFS_ECC_HW_AUTO 	->	硬件自动方式。这种方式下，ECC校验由NAND驱动程序完成，UFFS不做任何ECC校验工作。这种方式比较灵活，驱动程序可以
							自行决定ECC数据的存放位置。

3. UFFS_ECC_NONE 		->	无ECC校验方式。在这种方式下，UFFS不使用ECC校验，由于NAND芯片可能出现数据写入错误，并且ECC可以识别并纠正一定bit的
							错误（一般ECC可以纠正一个bit的错误，可以识别2个bit的错误但是无法纠正，但这并不绝对，ECC bits越多其纠错能力越强）。
							在NAND设备上通常会有一定的安全风险。

综上，当在NAND设备上使用UFFS时推荐使用方式二UFFS_ECC_HW_AUTO。


注意：UFFS不仅可以使用在NAND设备上，也可以使用NOR FLASH、SPI FLASH设备等。不过目前RT-Thread中的UFFS仅支持在NAND上使用，未来可能会考虑增加对NOR
FLASH以及SPI FLASH的支持。



12.8.2	UFFS内存精简
======================================================================================================



12.8.3	MTD NAND驱动
======================================================================================================



12.8.4	UFFS示例驱动
======================================================================================================
目前RT-Thread中使用UFFS还是比较容易的，stm32f10x，stm32f40x上实现了k9f1g08NAND的支持，并且在bsp/simulator恶意是用文件来模拟NAND，并支持UFFS模拟。

1. stm32f40x的k9f2g08.c驱动
https://github.com/RT-Thread/realtouch-stm32f4/blob/master/software/examples/
drivers/k9f2g08u0b.c
2. stm32f10x的k9f1g08.c驱动
https://github.com/prife/stm32f10x_demo/blob/master/wdrivers/k9f_nand.c



12.9	jffs2
======================================================================================================



12.10	yaffs
======================================================================================================



第13章	lwIP - 轻型TCP/IP协议栈
======================================================================================================
13.1	简介
======================================================================================================
lwIP（light-weight IP)最初由瑞士计算机科学院开发、维护的一套用于嵌入式系统的开放源代码TCP/IP协议栈，它在包含完整的TCP协议的基础上实现
了小型化的资源占用，因此它十分适合于应用到嵌入式设备中，其占用的资源体积RAM大概为几十kB，ROM大概为40KB。

lwIP结构精简，功能完善，因而用户群较为广泛。RT-Thread实时操作系统就采用了lwIP做为默认的TCP/IP协议栈，同时根据小型设备的特点对lwIP进行
了再次优化，使其资源占用体积进一步地缩小，RAM 的占用可缩小到5kB附近（未计算上层应用使用TCP/IP协议时的空间占用量）。本章内容将为您讲述
lwIP在RT-Thread中的使用方法。

主要特性（摘自lwIP官方网站，翻译如有错误请指正）：
? 协议：IP，ICMP，UDP，TCP，IGMP，ARP，PPPoS，PPPoE
? DHCP client，DNS client，AutoIP/APIPA(Zeroconf)，SNMP agent(private MIB support)
? APIs：专门针对增强性能实现的API接口，可选的类BSD的Socket API。
? 延伸的特点：多个网络接口的IP转发，TCP拥塞控制，RTT往返时间估算、快速恢复和
快速重传



13.2	协议分层
======================================================================================================
可能大家对OSI七层模型并不陌生，它将网络协议很细致地从逻辑上分为了7层。但是实际运用中并不是按七层模型，一般大家都只使用5层模型。
如下：
1: 物理层		->	一般包括物理媒介，电信号，光信号等，主要对应于PHY芯片，PHY芯片将数据传送给物理媒介（RJ45座->双绞线）
2: 数据链路层	->	一般简单称为MAC层，因为MAC芯片处于这层，对应于代码中的网卡驱动层。数据包在这一层一般称之为“以太网帧”。
3: 网络层		->	对应于代码中IP层。
4: 传输层		->	对应于代码中TCP层。
5: 应用层		->	对应于代码中应用层数据，即SOCKET通信,recv()/send()的数据。

对于一个以太网数据包，我们在代码中能真实看到的包括4部分，分别对应链路层、网络层、传输层、应用层，如下图：
以太网包格式：
		以太网帧头		IP头		TCP头		应用层（HTTP等应用协议）

注：有几个概念需要解释一下，从网卡收到的数据，此时是一个完整的包含各层头的数据包，此时称之为“以太网帧”；当解开以太网帧头到达IP层，称
之为“IP Packet（IP数据包）”；当解开IP头到达TCP层，称之为“TCP Segment（TCP分片）”；当解开TCP头时到达应用层，就是我们socket通信看到的数据了。
		
		
		
13.3	lwIP不遵循严格的分层
======================================================================================================
前面提到过TCP/IP的标准实现一般使用严格的分层，这对lwIP的设计与实现提供了指导意义。每个协议作为一个单独地模块，提供一些API作为协议的入口点。
尽管这些协议都单独地实现，但是一些层（协议之间）违背了严格的分层标准，这样做是为了提高处理的速度和内存的占用。		
		
比如：在TCP分片的报文中，为了计算TCP校验和，我们需要知道IP协议层的源IP地址和目的IP地址，一般我们会构造一个伪的IP头（包含IP地址信息等），而
常规的做法是通过IP协议层提供的API去获得这些IP地址，但是lwIP是拿到数据报文的IP头，从中解析得到IP地址。		
		
		
		
13.4	进程模型（process model）
======================================================================================================
TCP/IP的进程模型可以被设计为以下两种：（当然也可以是其他的模型）
1.  每层的协议都作为一个独立的进程在运行，这种方式的好处在于代码易于理解和调试；同样也有不好之处，每数据报文经过每一层时，都需要进行一次上下
	文的切换（因为每层协议都在不同的进程中），在操作系统中，上下文的切换耗费资源比较大。
2.  lwIP使用单进程模型，所有的协议都运行在一个进程中，并且与操作系统内核是分开的。应用程序可以驻留在lwIP进程中或者运行在一个分离的进程中，当
	应用程序与lwIP在一个进程中，协议栈和应用层通讯通过函数调用即可。		
		
这两种方法各有优缺点，lwIP之所以运行在一个分离地，单独地进程中，是因为这样易于不同的操作系统移植，为啥？与内核耦合性小。		
		
为了更方便移植，lwIP加了一层操作系统模拟层，只要实现这里面的提供的函数移植的基本工作就完成了。		
		
		
		
13.5 操作系统模拟层（OS emulation layer）
======================================================================================================		
不同的操作系统，提供不同的通信机制，而且这些通信的方法实现也不同，增加操作系统模拟层，将操作系统相关的功能函数和数据结构放在这一层中（对应于代
码sys.c/h），这一层提供诸如创建lwIP进程，延时，互斥锁，信号量，邮箱等相关的函数。		
		
		
		
13.6 RT-Thread中的lwIP
======================================================================================================		
由于原版的lwIP更适合于在无操作系统的情况下运行，所以RT-Thread在移植lwIP的过程中根据RT-Thread的特点进行了适当调整。

其结构如下图所示：		
RT-Thread操作系统中的lwIP是从lwIP发布原始版本移植过来，然后添加了设备层以替换原来的驱动层。不同于原版，这里RT-Thread对于以太网数据的收发采用了
独立的双线程（erx线程与etx线程）结构：		

1 ->	erx线程用于以太网报文的接收──当以太网硬件设备收到网络报文产生中断时，中断服务例程将会通过邮箱的形式唤醒erx线程，让erx线程主动进行以太网
		报文收取过程，当erx线程收到有效网络报文后，它通过邮箱的形式通知给LwIP的主线程（tcp线程）；		
		
2 ->	tcp的发送操作则是通过邮箱的形式唤醒etx线程进行实际的以太网硬件写入。在正常情况下，erx线程和etx线程的优先级是相同的，用户可以根据自身实际
		要求进行微调以侧重接收或发送。		
		
		
		
13.6.1 lwIP版本
======================================================================================================			
RT-Thread lwIP包含三个版本，分别为：“1.3.2”，“1.4.0”，“1.4.1”，其中“1.4.0”的文件夹没有标名版本号，查看具体的版本号可以在src/include/lwip/init.h中
查询。如下：

/** X.x.x: Major version of the stack */
#define LWIP_VERSION_MAJOR 1U
/** x.X.x: Minor version of the stack */
#define LWIP_VERSION_MINOR 4U
/** x.x.X: Revision of the stack */
#define LWIP_VERSION_REVISION 1U

RT-Thread通过宏去指定使用哪个版本的lwIP，熟悉RT-Thread的朋友都知道一般都是使用scons工具（类linux下的make工具）生成项目工程文件（MDK工程、IAR工程等）,
因此在每个版本的文件夹中包含了一个Sconscript文件，该文件中会依赖与相应的宏加入到工程文件中，以lwIP1.4.1中的Sconscript为例：		

group = DefineGroup('LwIP', src, depend = ['RT_USING_LWIP', 'RT_USING_LWIP141'], CPPPATH = path)		
		
大家可以看到加入该版本下的所有文件依赖与（RT_USING_LWIP、RT_USING_LWIP141）两个宏，这两个宏在RT-Thread源码的rtconfig.h中，这个文件与实际的项目（或者
说BSP、开发板相关），点开“bsp”目录下任何一个文件夹都可以找到rtconfig.h。因为这些宏是自己定义的，所以你可能在这个文件中找不到这些宏，如果你需要使用，
请自行添加吧，然后使用scons重新生成工程。		
		
		
		
13.6.2 RT-Thread 网络设备管理		
======================================================================================================					
		
		
		
13.6.3 RT-Thread lwIP有哪些变化		
======================================================================================================							
1	-> 	上面提到过，将sys.c/h中的接口实现基本的移植工作就完成了，细心的读者可能会拿RT-Thread中lwIP这部分源码与lwIP官方的源码做一个对比，然后会发
		现RT-Thread增加一个“arch”目录，这部分代码主要实现了前面提到的信号量、互斥锁、邮箱等sys.h文件中的接口，另外RT-Thread根据其系统自身增加
		了lwIP的初始化工作.

2	->	单纯在RT-Thread中完成lwIP初始化和创建lwIP线程的工作还是不够的，因为要让协议栈与外界通信，系统必须可以收发数据，所以还需要硬件驱动的支持，
		这时牵扯到RT-Thread收发包的设计和网卡驱动。

由此可知，RT-Thread中将lwIP应用起来主要包括三个核心步骤： 
1. 创建收发包线程，调用接口eth_system_device_init()。
2. 提供网卡驱动，调用网卡初始化函数，注册网卡设备。（驱动不同相应的接口函数可能不同） 
3. 初始化lwIP，创建lwIP线程，调用接口lwip_sys_init()（实际调用的lwip_system_init()）。

至此，三个步骤完成之后，应用层便可以直接与外界通讯。

  

13.6.4 RT-Thread lwIP相关代码补充说明		
======================================================================================================
前面我们讲解过lwip_system_init()中，当系统中没有网卡设备时，有一部分初始化工作（为网卡初始化IP、子网掩码、网关等）是不会进行的。此时lwIP线程已
经创建，如果需要和外界通讯，那么必须为系统添加网卡设备，而在网卡驱动中，网卡设备初始化时，会向系统注册，此时网卡设备就添加到系统中了。



13.7 IPv4协议栈概述
======================================================================================================
互联网协议版本4（Internet Protocol version 4，IPv4）是互联网协议开发过程中的第四个修订版本(网际网协四版)，也是此协议第一个被广泛部署的版本。

IPv4与IPv6均是标准化互联网络的核心部分。







		
		
		
		

